"""
Functions to analyze contact opportunities and optimization outputs
"""

import json
import statistics
from dataclasses import dataclass
from itertools import groupby

from brahe import Epoch

from models import GroundStationProvider, Satellite, Contact, GroundStation, OptimizationWindow, DataUnits
from plots import plot_stations

import matplotlib.pyplot as plt
import plotly.graph_objs as go


@dataclass
class SolutionContact:
    """
    Dataclass to store information about a contact in a solution
    """
    id: str
    provider_id: str
    satellite_id: str
    station_id: str

    t_start: Epoch
    t_end: Epoch
    t_duration: float

    cost: float
    cost_per_minute: float
    cost_per_pass: float
    datavolume: float

    def __post_init__(self):
        # Ensure that t_start and t_end are Epoch objects
        if not isinstance(self.t_start, Epoch):
            self.t_start = Epoch(self.t_start)

        if not isinstance(self.t_end, Epoch):
            self.t_end = Epoch(self.t_end)

@dataclass
class Solution:
    """
    Dataclass to store information about an optimization solution
    """

    runtime: dict[str, float]
    opt_window: OptimizationWindow
    satellite_dict: dict[str, Satellite]
    provider_dict: dict[str, GroundStationProvider]
    station_dict: dict[str, GroundStation]
    contact_dict: dict[str, SolutionContact]
    selected_provider_dict: dict[str, GroundStationProvider]
    selected_station_dict: dict[str, GroundStation]
    stations_by_satellite: dict[str: list[str]]

    @property
    def satellites(self):
        return list(self.satellite_dict.values())

    @property
    def providers(self):
        return list(self.provider_dict.values())

    @property
    def stations(self):
        return list(self.station_dict.values())

    @property
    def contacts(self):
        return list(self.contact_dict.values())

    @property
    def selected_stations(self):
        return list(self.selected_station_dict.values())


def load_solution_from_file(filepath: str):
    with open(filepath, 'r') as f:
        data = json.load(f)

    return load_solution(data)


def load_solution(data: dict):
    """
    Load an optimization solution from a JSON file and return the satellite, provider, station, and contact
    dictionaries. This function is useful for analyzing the results of an optimization run.

    Args:
        data (dict): Path to the JSON file containing the optimization solution

    Returns:
        solution (Solution): Dataclass containing the satellites, providers, stations, and contacts in the solution
    """

    # Parse Optimization Window
    # opt_window = OptimizationWindow(**data["optimization_window"])

    # Parse Providers
    providers = [GroundStationProvider.load_geojson(p) for p in data["providers"]]

    # Extract provider / station dictionaries
    provider_dict = {p.id: p for p in providers}
    station_dict = {s.id: s for p in providers for s in p.stations}

    # Parse Satellites
    satellite_dict = {s['id']:Satellite(**s) for s in data["satellites"]}

    # Parse Contacts
    contact_dict = {c['id']:SolutionContact(**c) for c in data["contacts"]}

    # # Extract providers that were selected in the solution
    # selected_provider_ids = set([c.provider_id for c in contact_dict.values()])
    # selected_provider_dict = {p_id:provider_dict[p_id] for p_id in selected_provider_ids}

    # # Extract stations that were selected in the solution
    # selected_station_ids = set([c.station_id for c in contact_dict.values()])
    # selected_station_dict = {s_id:station_dict[s_id] for s_id in selected_station_ids}

    # # Extract stations by satellite
    # stations_by_satellite = data['stations_by_satellite']

    return Solution(None, None, satellite_dict, provider_dict,
                    station_dict, contact_dict, None,
                    None, None)

def plot_solution_stations(solution: Solution, selected_only: bool = False):
    """
    A convenience function to plot the locations of the ground stations in a solution. This wraps utils.plot_stations
    and computes the elevation_min and alt based on minimum of all stations and satellites.


    Args:
        solution:

    Returns:

    """

    if selected_only:
        stations = list(solution.selected_station_dict.values())
    else:
        stations = list(solution.station_dict.values())

    elevation_min = min([s.elevation_min for s in stations])
    alt = min([s.alt for s in solution.satellite_dict.values()])

    return plot_stations([(s.lon, s.lat, s.provider) for s in stations], elevation_min=elevation_min, alt=alt)

def compute_contact_gaps(contacts: list[Contact] | list[SolutionContact]):
    """
    Compute the gaps between contacts in a list of contacts. The gap is defined as the time between the end of one
    contact and the start of the next contact. The function returns a list of contact gaps.

    Args:
        contacts: List of contacts to compute gaps for

    Returns:
        contact_gaps: List of contact gaps
    """

    contact_gaps = {}
    all_gaps = []


    for sat_id, sat_contacts in groupby(contacts, lambda c: c.satellite_id):

        contact_gaps[sat_id] = []

        # Sort the contacts by start time
        sorted_contacts = sorted(sat_contacts, key=lambda c: c.t_start)

        # Compute the gaps between contacts
        for i in range(1, len(sorted_contacts)):
            gap = sorted_contacts[i].t_start - sorted_contacts[i-1].t_end
            gap_stats = {
                'satellite_id': sorted_contacts[i].satellite_id,
                'gap_start': sorted_contacts[i-1].t_end,
                'gap_end': sorted_contacts[i].t_start,
                'gap_duration_s': gap,
                'contact_before_id': sorted_contacts[i-1].id,
                'contact_after_id': sorted_contacts[i].id
            }

            all_gaps.append(gap_stats)
            contact_gaps[sat_id].append(gap_stats)

    contact_gaps['all'] = all_gaps
    return contact_gaps

def compute_gap_statistics(contact_gaps: list[dict]):

    # Compute the total number of gaps
    num_gaps = len(contact_gaps)

    # Compute the average gap duration
    mean_gap_duration = sum([g['gap_duration_s'] for g in contact_gaps]) / num_gaps

    # Compute the maximum gap duration
    max_gap_duration = max([g['gap_duration_s'] for g in contact_gaps])

    # Compute the minimum gap duration
    min_gap_duration = min([g['gap_duration_s'] for g in contact_gaps])

    # Compute 5 and 95 percentiles
    sorted_gap_durations = sorted([g['gap_duration_s'] for g in contact_gaps])

    gap_duration_s_p05 = 0
    gap_duration_s_p95 = 0

    if len(sorted_gap_durations) > 2:
        gap_duration_s_p5bins = statistics.quantiles(sorted_gap_durations, n=20)
        gap_duration_s_p05 = gap_duration_s_p5bins[0]
        gap_duration_s_p95 = gap_duration_s_p5bins[18]

    return {
        'num_gaps': num_gaps,
        'mean_gap_duration_s': mean_gap_duration,
        'max_gap_duration_s': max_gap_duration,
        'min_gap_duration_s': min_gap_duration,
        'gap_duration_s_p05': gap_duration_s_p05,
        'gap_duration_s_p95': gap_duration_s_p95
    }

def compute_contact_statistics(contacts: list[Contact] | list[SolutionContact]):

    # Compute the total number of contacts
    num_contacts = len(contacts)

    # Compute the average contact duration
    mean_duration = sum([c.t_duration for c in contacts]) / num_contacts

    # Compute the maximum contact duration
    max_duration = max([c.t_duration for c in contacts])

    # Compute the minimum contact duration
    min_duration = min([c.t_duration for c in contacts])

    # Compute 5 and 95 percentiles
    sorted_durations = sorted([c.t_duration for c in contacts])
    contact_duration_s_p5bins = statistics.quantiles(sorted_durations, n=20)
    contact_duration_s_p05 = contact_duration_s_p5bins[0]
    contact_duration_s_p95 = contact_duration_s_p5bins[18]

    sat_contact_stats = {}
    sat_gap_stats = {}

    # Compute per-satellite contact statistics
    for sat_id, sat_contacts in groupby(contacts, lambda c: c.satellite_id):
        sat_contacts = list(sat_contacts)
        sat_mean_duration = sum([c.t_duration for c in sat_contacts]) / len(sat_contacts)
        sat_max_duration = max([c.t_duration for c in sat_contacts])
        sat_min_duration = min([c.t_duration for c in sat_contacts])
        sat_sorted_durations = sorted([c.t_duration for c in sat_contacts])

        sat_duration_s_p05 = 0
        sat_duration_s_p95 = 0

        if len(sat_sorted_durations) > 2:
            sat_duration_s_p5bins = statistics.quantiles(sat_sorted_durations, n=20)
            sat_duration_s_p05 = sat_duration_s_p5bins[0]
            sat_duration_s_p95 = sat_duration_s_p5bins[18]

        sat_contact_stats[sat_id] = {
            'num_contacts': len(sat_contacts),
            'mean_duration_s': sat_mean_duration,
            'max_duration_s': sat_max_duration,
            'min_duration_s': sat_min_duration,
            'duration_s_p05': sat_duration_s_p05,
            'duration_s_p95': sat_duration_s_p95
        }

        # Compute contact gaps
        sat_contact_gaps = compute_contact_gaps(sat_contacts)[sat_id]

        if len(sat_contact_gaps) > 0:
            sat_gap_stats[sat_id] = compute_gap_statistics(sat_contact_gaps)
        else:
            sat_gap_stats[sat_id] = {}

    return {
        'num_contacts': num_contacts,
        'mean_duration_s': mean_duration,
        'max_duration_s': max_duration,
        'min_duration_s': min_duration,
        'duration_s_p05': contact_duration_s_p05,
        'duration_s_p95': contact_duration_s_p95,
        'satellite_contact_stats': sat_contact_stats,
        'satellite_gap_stats': sat_gap_stats
    }

def plot_contact_duration_histogram(contacts: list[Contact] | list[SolutionContact], satellite_id: str | None = None, units: str = 'minutes', x_axis_min: float = 0):

    if satellite_id is not None:
        contacts = [c for c in contacts if c.satellite_id == satellite_id]

    durations = [c.t_duration for c in contacts]

    # Change duration into minutes for better visualization
    if units == 'minutes':
        durations = [d/60 for d in durations]

    fig = go.Figure(
        data=[go.Histogram(x=durations)]  # Set bin width to 2
    )

    # Set title
    fig.update_layout(
        title_text="Contact Duration Histogram"
    )

    # Set axis labels
    fig.update_xaxes(title_text=f"Duration ({units})")
    fig.update_yaxes(title_text="Count")

    # Change color of the bars
    fig.update_traces(marker_color='blue', marker_line_color='black', marker_line_width=1)

    # Set x-axis lower limit to 0
    fig.update_xaxes(range=[x_axis_min, None])

    return fig


def plot_contact_gap_histogram(contact_gaps, satellite_id: str | None = None, units: str = 'minutes', x_axis_min: float = 0, bin_width: float = 5.0):

    # Compute contact gaps
    if satellite_id is not None:
        contact_gaps = contact_gaps[satellite_id]
    else:
        contact_gaps = contact_gaps['all']

    gap_durations = [g['gap_duration_s'] for g in contact_gaps]

    # Change duration into minutes for better visualization
    if units == 'minutes':
        gap_durations = [d/60 for d in gap_durations]

    fig = go.Figure(

        data=[go.Histogram(x=gap_durations, xbins={'size': bin_width})]
    )

    # Set title
    fig.update_layout(
        title_text="Contact Gap Histogram"
    )

    # Set axis labels
    fig.update_xaxes(title_text=f"Gap Duration ({units})")
    fig.update_yaxes(title_text="Count")

    # Change color of the bars
    fig.update_traces(marker_color='blue', marker_line_color='black', marker_line_width=1)

    # Set x-axis lower limit to 0

    fig.update_xaxes(range=[x_axis_min, None])

    return fig

def analyze_solution(solution: Solution, data_unit: DataUnits = DataUnits.b):
    """
    Analyze an optimization solution and return statistics about the contacts and gaps in the solution.

    Args:
        solution: Solution object containing the satellites, providers, stations, and contacts in the solution

    Returns:
        contact_stats: Dictionary containing statistics about the contacts in the solution
        gap_stats: Dictionary containing statistics about the gaps between contacts in the solution
    """

    # Compute contact statistics
    contact_stats = compute_contact_statistics(solution.contacts)

    # Compute contact gaps
    contact_gaps = compute_contact_gaps(solution.contacts)

    # Compute gap statistics
    gap_stats = compute_gap_statistics(contact_gaps['all'])

    # Cost and data downlink statistics are repetitions of the values
    # saved in the solution JSON file. They are computed here for convenience and
    # cross-verification.

    # Compute Costs
    total_cost = 0.0
    total_fixed_cost = 0.0
    total_operational_cost = 0.0
    monthly_operational_cost = 0.0

    ## Provider Costs - Fixed
    for pn_id, pn in solution.selected_provider_dict.items():
        total_cost += pn.integration_cost
        total_fixed_cost += pn.integration_cost

    ## Station Costs - Fixed & Operational
    for sn_id, sn in solution.selected_station_dict.items():
        total_cost += sn.setup_cost
        total_fixed_cost += sn.setup_cost

        extr_opt_cost = (12 * solution.opt_window.T_opt) / (365.25 * 86400.0) * sn.monthly_cost
        total_cost += extr_opt_cost
        total_operational_cost += extr_opt_cost
        monthly_operational_cost += sn.monthly_cost

    ## Add Satellite Licensing Costs
    for sat_id in solution.stations_by_satellite.keys():
        for station_id in solution.stations_by_satellite[sat_id]:
            total_cost += solution.station_dict[station_id].per_satellite_license_cost

    ## Contact Costs - Operational
    for cn_id, cn in solution.contact_dict.items():
        total_cost += solution.opt_window.T_opt / solution.opt_window.T_sim * cn.cost
        total_operational_cost += solution.opt_window.T_opt / solution.opt_window.T_sim * cn.cost
        monthly_operational_cost += cn.cost / solution.opt_window.T_sim * (365.25 * 86400.0) / 12.0

    # Data Downlink Statistics
    total_data_downlinked = sum([c.datavolume for c in solution.contacts]) * solution.opt_window.T_opt / solution.opt_window.T_sim
    total_data_downlinked = total_data_downlinked / data_unit.value

    datavolume_by_satellite = {
        'total': {},
        'daily_avg': {},
    }

    for sat_id, sat_contacts in groupby(solution.contacts, lambda c: c.satellite_id):
        datavolume_by_satellite['total'][sat_id] = sum([c.datavolume for c in sat_contacts]) * solution.opt_window.T_opt / solution.opt_window.T_sim / data_unit.value
        datavolume_by_satellite['daily_avg'][sat_id] = datavolume_by_satellite['total'][sat_id] / (solution.opt_window.T_opt / 86400.0)

    return {
        'runtime': {
        },
        'contact_stats': contact_stats,
        'gap_stats': gap_stats,
        'costs': {
            'total_cost': total_cost,
            'total_fixed_cost': total_fixed_cost,
            'total_operational_cost': total_operational_cost,
            'monthly_operational_cost': monthly_operational_cost
        },
        'data_downlink': {
            'total_data_downlinked': total_data_downlinked,
            'datavolume_by_satellite': datavolume_by_satellite
        }
    }"""
This module contains helper functions for generating different simulation scenarios for evaluation and demonstration.
"""

import copy
import random
import os
import pathlib

import polars as pl
from rich.console import Console, ConsoleOptions, RenderResult
from rich.table import Table

from gsopt.ephemeris import get_satcat_df
from gsopt.models import GroundStationProvider, OptimizationWindow, Satellite
from gsopt.widgets import satellites_from_dataframe

# Get directory of current file
DIR = pathlib.Path(__file__).parent.absolute()

PROVIDERS = os.listdir(DIR / '..' / 'data' / 'groundstations')

CONSTELLATIONS = sorted(['YAM', 'UMBRA', 'SKYSAT', 'ICEYE', 'FLOCK', 'HAWK', 'CAPELLA', 'LEGION', 'WORLDVIEW', 'GEOEYE',
                  'NUSAT'])

class Random(random.Random):
    """
    Custom Random class that allows for seeding with a string or bytes object. This is useful for reproducibility.
    It also allows for retrieving the current seed value.
    """

    def seed(self, a=None, version=2, num_bytes=2500):
        # Note num_bytes should normally be really big (like 2500) to ensure that the seed is long enough to span the
        # entire state space of the Mersenne Twister. However, for the purposes of this project, we don't need to worry
        # about that.
        from os import urandom as _urandom
        from hashlib import sha512 as _sha512
        if a is None:
            try:
                # Seed with enough bytes to span the 19937 bit
                # state space for the Mersenne Twister
                a = int.from_bytes(_urandom(num_bytes), 'big')
            except NotImplementedError:
                import time
                a = int(time.time() * 256)  # use fractional seconds

        if version == 2:
            if isinstance(a, (str, bytes, bytearray)):
                if isinstance(a, str):
                    a = a.encode()
                a += _sha512(a).digest()
                a = int.from_bytes(a, 'big')

        self._current_seed = a
        super().seed(a)

    def get_seed(self):
        return self._current_seed

class Scenario():
    def __init__(self, opt_window: OptimizationWindow, providers: list[GroundStationProvider], satellites: list[Satellite], seed=None):
        self.opt_window = opt_window
        self.providers = providers
        self.satellites = satellites
        self.seed = seed

    def __rich_console__(self, console: Console, options: ConsoleOptions) -> RenderResult:
        for provider in self.providers:
            console.print(provider)

            for station in provider.stations:
                console.print(station)

        for satellite in self.satellites:
            console.print(satellite)

        tbl = Table(title='Scenario Summary')
        tbl.add_column('Property')
        tbl.add_column('Value')

        tbl.add_row('Optimization Window', f'{self.opt_window.opt_start} to {self.opt_window.opt_end}')
        tbl.add_row('Simulation Window', f'{self.opt_window.sim_start} to {self.opt_window.sim_end}')
        tbl.add_row('Number of Providers', str(len(self.providers)))
        tbl.add_row('Number of Satellites', str(len(self.satellites)))
        tbl.add_row('Seed', str(hex(self.seed)))

        yield tbl

class ScenarioGenerator():

    def __init__(self, opt_window: OptimizationWindow | None = None, seed=None):
        # Create a random number generator
        self.seed = None
        self._rng = Random(seed)

        # Initialize storage variables
        self.providers = []
        self.satellites = []
        self.opt_window = opt_window

        # Load the satellite catalog data from Celestrak
        self._satcat_df = get_satcat_df()

        # Store randomization parameters
        self._sat_datarate_ranges = {'default': (0.9e9, 1.8e9)}
        self._provider_elevation_min = {'default': 10.0}
        self._provider_integration_cost = {'default': (50000.0, 200000.0)}
        self._provider_setup_cost = {'default': (10000.0, 100000.0)}
        self._provider_per_satellite_license_cost = {'default': (1000.0, 5000.0)}
        self._provider_monthly_cost = {'default': (200.0, 5000.0)}
        self._provider_datarate = {'default': (1.2e9, 2.0e9)}
        self._provider_probability_of_pass_pricing = {'default': 0.5}
        self._provider_cost_per_pass = {'default': (25.0, 175.0)}
        self._provider_cost_per_minute = {'default': (5.0, 35.0)}
        self._provider_num_antennas = {'default': (1, 3)}

    def set_seed(self, seed):
        self._rng.seed(seed)

    def add_provider(self, provider: str):

        if provider not in PROVIDERS:
            raise ValueError(f'Provider {provider} not found in {PROVIDERS}')

        provider_file = DIR / '..' / 'data' / 'groundstations' / provider

        with open(provider_file, 'r') as f:
            self.providers.append(GroundStationProvider.load_geojson_file(f))

    def add_all_providers(self):
        for provider in PROVIDERS:
            self.add_provider(provider)

    def _set_provider_property(self, property_name, value, provider_name=None):
        if provider_name is None:
            getattr(self, f'_provider_{property_name}')['default'] = value

        else:
            if provider_name not in self.get_provider_names():
                raise ValueError(f'Provider {provider_name} not found in scenario providers. Add the provider before setting the property')

            getattr(self, f'_provider_{property_name}')[provider_name] = value

    def set_provider_elevation_min(self, elevation_min: float, provider_name: str | None = None):
        """
        Set the minimum elevation angle. This is the minimum angle above the horizon that a satellite must be to be
        visible to the ground station.

        If provider_name is None, the elevation angle will be set for all providers. Otherwise, it will be set for the
        specified provider.

        Args:
            elevation_min (float): Minimum elevation angle in degrees
            provider_name (str): Name of the provider to set the elevation angle for. Optional.
        """
        self._set_provider_property('elevation_min', elevation_min, provider_name)

    def set_provider_integration_cost(self, integration_cost_range: tuple[float, float], provider_name: str | None = None):
        """
        Set the integration cost for the ground station provider. This is the one-time cost to integrate with the
        provider network.

        If provider_name is None, the integration cost will be set for all providers. Otherwise, it will be set for the
        specified provider.

        Args:
            integration_cost_range (tuple): Tuple of the form (min, max) representing the range of integration costs to
                sample from
            provider_name (str): Name of the provider to set the integration cost for. Optional.
        """
        self._set_provider_property('integration_cost', integration_cost_range, provider_name)

    def set_provider_setup_cost(self, setup_cost_range: tuple[float, float], provider_name: str | None = None):
        """
        Set the setup cost for the ground station provider. This is the one-time cost to set up a new ground station.

        If provider_name is None, the setup cost will be set for all providers. Otherwise, it will be set for the
        specified provider.

        Args:
            setup_cost_range (tuple): Tuple of the form (min, max) representing the range of setup costs to sample from
            provider_name (str): Name of the provider to set the setup cost for. Optional.
        """

        self._set_provider_property('setup_cost', setup_cost_range, provider_name)

    def set_provider_per_satellite_license_cost(self, per_satellite_license_cost_range: tuple[float, float], provider_name: str | None = None):
        """
        Set the per-satellite license cost for the ground station provider. This is the cost to license a new satellite
        for use with the provider network.

        If provider_name is None, the per-satellite license cost will be set for all providers. Otherwise, it will be
        set for the specified provider.

        Args:
            per_satellite_license_cost_range (tuple): Tuple of the form (min, max) representing the range of license costs
                to sample from
            provider_name (str): Name of the provider to set the license cost for. Optional.
        """
        self._set_provider_property('per_satellite_license_cost', per_satellite_license_cost_range, provider_name)

    def set_provider_monthly_cost(self, monthly_cost_range: tuple[float, float], provider_name: str | None = None):
        """
        Set the monthly cost for the ground station provider. This is the cost per month to maintain a ground station.

        If provider_name is None, the monthly cost will be set for all providers. Otherwise, it will be set for the
        specified provider.

        Args:
            monthly_cost_range (tuple): Tuple of the form (min, max) representing the range of monthly costs to sample from
            provider_name (str): Name of the provider to set the monthly cost for. Optional.
        """
        self._set_provider_property('monthly_cost', monthly_cost_range, provider_name)

    def set_provider_datarate(self, datarate_range: tuple[float, float], provider_name: str | None = None):
        """
        Set the maximum data rate for the ground station provider. This is the maximum data rate that the provider can
        support.

        If provider_name is None, the data rate will be set for all providers. Otherwise, it will be set for the
        specified provider.

        Args:
            datarate_range (tuple): Tuple of the form (min, max) representing the range of data rates to sample from
            provider_name (str): Name of the provider to set the data rate for. Optional.
        """
        self._set_provider_property('datarate', datarate_range, provider_name)

    def set_provider_probability_of_pass_pricing(self, probability_of_pass_pricing: float, provider_name: str | None = None):
        """
        Set the probability of pass pricing for the ground station provider. This is the probability that the provider
        will charge per pass rather than per minute.

        If provider_name is None, the probability of pass pricing will be set for all providers. Otherwise, it will be
        set for the specified provider.

        Args:
            probability_of_pass_pricing (float): Probability of pass pricing, between 0 and 1
            provider_name (str): Name of the provider to set the probability of pass pricing for. Optional.

        """
        self._set_provider_property('probability_of_pass_pricing', probability_of_pass_pricing, provider_name)

    def set_provider_cost_per_pass(self, cost_per_pass_range: tuple[float, float], provider_name: str | None = None):
        """
        Set the cost per pass for the ground station provider. This is the cost to download data from a satellite during a
        single pass.

        If provider_name is None, the cost per pass will be set for all providers. Otherwise, it will be set for the
        specified provider.

        Args:
            cost_per_pass_range (tuple): Tuple of the form (min, max) representing the range of pass costs to sample from
            provider_name (str): Name of the provider to set the pass cost for. Optional.

        """
        self._set_provider_property('cost_per_pass', cost_per_pass_range, provider_name)

    def set_provider_cost_per_minute(self, cost_per_minute_range: tuple[float, float], provider_name: str | None = None):
        """
        Set the cost per minute for the ground station provider. This is the cost to download data from a satellite for
        each minute of contact time.

        If provider_name is None, the cost per minute will be set for all providers. Otherwise, it will be set for the
        specified provider.

        Args:
            cost_per_minute_range (tuple): Tuple of the form (min, max) representing the range of minute costs to sample from
            provider_name (str): Name of the provider to set the minute cost for. Optional.

        """
        self._set_provider_property('cost_per_minute', cost_per_minute_range, provider_name)

    def set_provider_num_antennas(self, num_antennas_range: tuple[int, int], provider_name: str | None = None):
        """
        Set the number of antennas for the ground station provider. This is the number of antennas at each ground station.

        If provider_name is None, the number of antennas will be set for all providers. Otherwise, it will be set for the
        specified provider.

        Args:
            num_antennas_range (tuple): Tuple of the form (min, max) representing the range of antennas to sample from
            provider_name (str): Name of the provider to set the antennas for. Optional.

        """
        self._set_provider_property('num_antennas', num_antennas_range, provider_name)

    def set_satellite_random_datarate(self, datarate_range: tuple[float, float], sat_id: str | None = None):
        if sat_id is None:
            self._sat_datarate_ranges['default'] = datarate_range

        else:
            if sat_id not in self.satellite_ids():
                raise ValueError(f'Satellite {sat_id} not found in scenario satellites. Add the satellite before setting the datarate.')

            self._sat_datarate_ranges[sat_id] = datarate_range

    def add_constellation(self, name=str):
        """
        Add a constellation of satellites to the scenario generator

        Args:
            name: str: Name of the constellation to add. Must be one of the following:
                - YAM
                - UMBRA
                - SKYSAT
                - ICEYE
                - FLOCK
                - HAWK
                - CAPELLA
                - LEGION
                - WORLDVIEW
                - GEOEYE

        """
        if name.upper() not in CONSTELLATIONS:
            raise ValueError(f'Constellation {name} not found in {CONSTELLATIONS}')

        constellation_sats = self._satcat_df.filter(pl.col('object_name').str.contains(name.upper()))

        self.satellites.extend(satellites_from_dataframe(constellation_sats))

    def add_satellite(self, sat_id: str | int):
        """
        Add a specific satellite to the scenario generator

        Args:
            sat_id: str: NORAD ID of the satellite to add
        """
        sat = self._satcat_df.filter(pl.col('satcat_id') == str(sat_id))
        self.satellites.extend(satellites_from_dataframe(sat))

    def add_random_satellites(self, num_satellites: int, alt_range: tuple = (300, 1000)):
        """
        Add a random selection of satellites to the scenario generator

        Args:
            num_satellites: int: Number of random satellites to add
            sma_range: tuple: Range of altitudes to select random satellites from
        """

        # Get all satellites with altitudes within the specified range
        random_sats = self._satcat_df.filter(pl.col('altitude').is_between(alt_range[0], alt_range[1]))

        # Get all unique satellite NORAD IDs
        sat_ids = list(sorted(random_sats['satcat_id'].unique().to_list()))

        # Randomly select a subset of the satellite NORAD IDs
        selected_sat_ids = self._rng.sample(sat_ids, num_satellites)

        # Filter the satellite catalog DataFrame to only include the selected satellites
        selected_sats = self._satcat_df.filter(pl.col('satcat_id').is_in(selected_sat_ids))

        # Add the selected satellites to the scenario generator
        self.satellites.extend(satellites_from_dataframe(selected_sats))

    def satellite_ids(self):
        for sat in self.satellites:
            yield sat.satcat_id

    def provider_names(self):
        for provider in self.providers:
            yield provider.name

    def get_provider_names(self):
        return [p.name for p in self.providers]

    @property
    def num_satellites(self):
        return len(self.satellites)

    def get_seed(self):
        return self._rng.get_seed()

    def sample_scenario(self) -> Scenario:
        """
        Sample a scenario from the scenario generator

        Returns:
            Scenario: The sampled scenario
        """

        # Create copies of the providers and satellites

        opt_window = copy.deepcopy(self.opt_window)
        providers = [copy.deepcopy(p) for p in self.providers]
        satellites = [copy.deepcopy(s) for s in self.satellites]

        # Set properites for the providers based on the scenario generator settings
        for provider in providers:
            provider.set_property('elevation_min', self._provider_elevation_min.get(provider.name, self._provider_elevation_min['default']))
            provider.integration_cost = self._rng.uniform(*self._provider_integration_cost.get(provider.name, self._provider_integration_cost['default']))
            provider.set_property('setup_cost', self._rng.uniform(*self._provider_setup_cost.get(provider.name, self._provider_setup_cost['default'])))

            provider_cost_type = self._rng.uniform(0, 1) >= self._provider_probability_of_pass_pricing.get(provider.name, self._provider_probability_of_pass_pricing['default'])

            for station in provider.stations:

                # Randomize number of antennas
                provider.set_property('antennas', self._rng.randint(*self._provider_num_antennas.get(provider.name, self._provider_num_antennas['default'])), key=station.id)

                # Randomize monthly cost, per satellite license cost, and data rate for each station
                provider.set_property('monthly_cost', self._rng.uniform(
                    *self._provider_monthly_cost.get(provider.name, self._provider_monthly_cost['default'])),
                                      key=station.id)

                provider.set_property('per_satellite_license_cost', self._rng.uniform(
                    *self._provider_per_satellite_license_cost.get(provider.name,
                                                                   self._provider_per_satellite_license_cost[
                                                                       'default'])), key=station.id)

                provider.set_property('datarate', self._rng.uniform(
                    *self._provider_datarate.get(provider.name, self._provider_datarate['default'])),
                                      key=station.id)

                # Set station costs
                if provider_cost_type:
                    provider.set_property('cost_per_pass', self._rng.uniform(*self._provider_cost_per_pass.get(provider.name, self._provider_cost_per_pass['default'])), key=station.id)
                    provider.set_property('cost_per_minute', 0.0, key=station.id)
                else:
                    provider.set_property('cost_per_pass', 0.0, key=station.id)
                    provider.set_property('cost_per_minute', self._rng.uniform(*self._provider_cost_per_minute.get(provider.name, self._provider_cost_per_minute['default'])), key=station.id)

        # Set properties for the satellites based on the scenario generator settings
        for satellite in satellites:
            satellite.datarate = self._rng.uniform(*self._sat_datarate_ranges.get(satellite.satcat_id, self._sat_datarate_ranges['default']))

        # Create the scenario
        scenario = Scenario(opt_window, providers, satellites, self._rng.get_seed())

        # Reinitialize the random number generator to ensure reproducibility
        if self.seed is None:
            self._rng = Random()

        return scenario
import enum
import uuid
import json
import logging
from datetime import datetime, timedelta
from rich.console import Console, ConsoleOptions, RenderResult
from rich.table import Table

from brahe import TLE, tle_string_from_elements, mean_motion, Epoch, sun_sync_inclination, R_EARTH
import brahe.data_models as bdm

logger = logging.getLogger(__name__)

class DataUnits(enum.Enum):
    b = 1
    bits = b
    B = 8
    bytes = B
    Kb = 1e3
    kilobits = Kb
    KB = 8 * 1e3
    kilobytes = KB
    Mb = 1e6
    megabits = Mb
    MB = 8 * 1e6
    megabytes = MB
    Gb = 1e9
    gigabits = Gb
    GB = 8 * 1e9
    gigabytes = GB
    Tb = 1e12
    terabits = Tb
    TB = 8 * 1e12
    terabytes = TB


class OptimizationWindow():

    def __init__(self, opt_start: datetime | Epoch | str, opt_end: datetime | Epoch | str, sim_start: datetime | Epoch | str, sim_end: datetime | Epoch | str):

        if not opt_start or not opt_end:
            raise ValueError("Optimization window must have start and end times")

        if not sim_start or not sim_end:
            logger.debug("No simulation window provided. Using default 7-day simulation window")
            sim_start = Epoch(opt_start)
            sim_end = sim_start + 7 * 86400.0

        self.opt_start = Epoch(opt_start)
        self.opt_end = Epoch(opt_end)
        self.sim_start = Epoch(sim_start)
        self.sim_end = Epoch(sim_end)

        if opt_start > opt_end:
            raise ValueError("Optimization start time must be before optimization end time")

        if sim_start > sim_end:
            raise ValueError("Simulation start time must be before simulation end time")

        self.T_opt = self.opt_end - self.opt_start
        self.T_sim = self.sim_end - self.sim_start

    @property
    def sim_duration(self):
        """
        Get the duration of the simulation window in seconds.

        Returns:
            - float: Duration of the simulation window in seconds
        """
        return self.sim_end - self.sim_start

    @property
    def opt_duration(self):
        """
        Get the duration of the optimization window in seconds.

        Returns:
            - float: Duration of the optimization window in seconds
        """
        return self.opt_end - self.opt_start

    def as_dict(self):
        return {
            'opt_start': self.opt_start.isoformat(),
            'opt_end': self.opt_end.isoformat(),
            'sim_start': self.sim_start.isoformat(),
            'sim_end': self.sim_end.isoformat()
        }

class GroundStation():

    def __init__(self, name: str, longitude: float, latitude: float,
                 altitude: float = 0.0,
                 id: str | None = None,
                 provider: str | None = None,
                 provider_id: str | None = None,
                 elevation_min: float = 0.0,
                 datarate: float = 0.0,
                 setup_cost: float = 0.0,
                 per_satellite_license_cost: float = 0.0,
                 monthly_cost: float = 0.0,
                 cost_per_pass: float = 0.0,
                 cost_per_minute: float = 0.0,
                 antennas: int = 1,
                 ):

        if not name:
            raise ValueError("Ground station must have a name")

        if longitude < -180 or longitude > 180:
            raise ValueError("Longitude must be between -180 and 180 degrees")

        if latitude < -90 or latitude > 90:
            raise ValueError("Latitude must be between -90 and 90 degrees")

        if altitude < 0:
            raise ValueError("Altitude must be greater than or equal to 0")

        self.id = id

        if not id:
            self.id = str(uuid.uuid4())

        self.name = name
        self.provider = provider
        self.provider_id = provider_id
        self.longitude = longitude
        self.latitude = latitude
        self.altitude = altitude
        self.elevation_min = elevation_min

        # Set cost objects
        self.setup_cost = setup_cost
        self.per_satellite_license_cost = per_satellite_license_cost
        self.monthly_cost = monthly_cost
        self.cost_per_pass = cost_per_pass
        self.cost_per_minute = cost_per_minute

        # Set data rate
        self.datarate = datarate

        # Set antenna count
        self.antennas = antennas

    @classmethod
    def from_geojson(cls, data: dict):
        """
        Create a GroundStation object from a GeoJSON dictionary
        """

        properties = data['properties']
        geometry = data['geometry']

        if geometry['type'] != 'Point':
            raise ValueError("Only Point geometries are supported")

        if 'provider' not in properties:
            raise ValueError("Missing 'provider' property")

        if 'name' not in properties:
            raise ValueError("Missing 'name' property")

        return cls(
            id=properties['id'] if 'id' in properties else None,
            name=properties['name'],
            provider=properties['provider'],
            provider_id=properties['provider_id'] if 'provider_id' in properties else None,
            longitude=geometry['coordinates'][0],
            latitude=geometry['coordinates'][1],
            altitude=geometry['coordinates'][2] if len(geometry['coordinates']) > 2 else 0.0,
            elevation_min=properties['elevation_min'] if 'elevation_min' in properties else 0.0,
            datarate=properties['datarate'] if 'datarate' in properties else 0.0,
            setup_cost=properties['setup_cost'] if 'setup_cost' in properties else 0.0,
            per_satellite_license_cost=properties['per_satellite_license_cost'] if 'per_satellite_license_cost' in properties else 0.0,
            monthly_cost=properties['monthly_cost'] if 'monthly_cost' in properties else 0.0,
            cost_per_pass=properties['cost_per_pass'] if 'cost_per_pass' in properties else 0.0,
            cost_per_minute=properties['cost_per_minute'] if 'cost_per_minute' in properties else 0.0,
            antennas=properties['antennas'] if 'antennas' in properties else 1
        )

    @property
    def lon(self):
        return self.longitude

    @property
    def lat(self):
        return self.latitude

    @property
    def alt(self):
        return self.altitude

    def as_brahe_model(self):
        return bdm.Station(
            **{
                "properties": {
                    "constraints": bdm.AccessConstraints(elevation_min=self.elevation_min),
                    "name": self.name,
                },
                "type": "Feature",
                "geometry": {
                    "type": "Point",
                    "coordinates": [self.longitude, self.latitude, self.altitude]
                },
            }
        )

    def as_geojson(self):
        return {
            "type": "Feature",
            "geometry": {
                "type": "Point",
                "coordinates": [self.lon, self.lat, self.alt]
            },
            "properties": {
                "id": self.id,
                "name": self.name,
                "provider": self.provider,
                "elevation_min": self.elevation_min,
                "datarate": self.datarate,
                "setup_cost": self.setup_cost,
                "per_satellite_license_cost": self.per_satellite_license_cost,
                "monthly_cost": self.monthly_cost,
                "cost_per_pass": self.cost_per_pass,
                "cost_per_minute": self.cost_per_minute,
                "antennas": self.antennas
            }
        }

    def __rich_console__(self, console: Console, options: ConsoleOptions) -> RenderResult:
        tbl = Table(title=f"{self.name.capitalize()} Station")

        tbl.add_column("Property", justify="left")
        tbl.add_column("Value")

        tbl.add_row("Name", self.name)
        tbl.add_row("Id", self.id)
        tbl.add_row("Provider", self.provider)
        tbl.add_row("Provider Id", self.provider_id)
        tbl.add_row("Longitude [deg]", f"{self.lon:.3f}")
        tbl.add_row("Latitude [deg]", f"{self.lat:.3f}")
        tbl.add_row("Altitude [m]", f"{self.alt:.3f}")
        tbl.add_row("Elevation Min [deg]", f"{self.elevation_min:.3f}")
        tbl.add_row("Setup Cost", f"${self.setup_cost:.2f}")
        tbl.add_row("Per Satellite License Cost", f"${self.per_satellite_license_cost:.2f}")
        tbl.add_row("Monthly Cost", f"${self.monthly_cost:.2f}")
        tbl.add_row("Cost per Pass", f"${self.cost_per_pass:.2f}")
        tbl.add_row("Cost per Minute", f"${self.cost_per_minute:.2f}")
        tbl.add_row("Data Rate [Mbps]", f"{self.datarate * 1e-6:.3f}")
        tbl.add_row("Antennas", f"{self.antennas:d}")

        yield tbl

class GroundStationProvider():
    """
    A GroundStationProvider represents the ground stations of a single ground station provider.
    """

    def __init__(self, stations: list[GroundStation] | None = None,
                 integration_cost: float = 0.0, id: str | None = None):

        self.provider = None
        self.id = id if id else str(uuid.uuid4())

        if not stations:
            self.stations = []
        else:
            self.stations = stations

        # Ensure all stations have the same provider ID
        for sta in self.stations:
            sta.provider_id = self.id

        if len(self.stations) > 0:
            self.provider = self.stations[0].provider

            # Check consistency of provider
            for sta in self.stations:
                if sta.provider != self.provider:
                    raise RuntimeError(f"Found unexpected provider \"{sta.provider}\". All stations in a provider must "
                                       f"share the same provider.")

        # Create Lookups:
        self._station_id_lookup = {sta.id: sta for sta in self.stations}
        self._station_name_lookup = {sta.name: sta for sta in self.stations}

        self.integration_cost = integration_cost

    @property
    def name(self):
        return self.provider

    @classmethod
    def load_geojson(cls, data, integration_cost: float = 0.0):
        """
        Load a GroundStationProvider from a GeoJSON dictionary

        Args:
            - data (dict): The GeoJSON dictionary to load
        """

        if "type" not in data.keys():
            raise RuntimeError("File missing expected GeoJSON field \"type\"")

        if data["type"] == "FeatureCollection":

            stations = [GroundStation.from_geojson(obj) for obj in data["features"]]

            integration_cost = 0.0
            id = None

            if "properties" in data and "properties" in data:
                if "integration_cost" in data["properties"]:
                    integration_cost = data["properties"]["integration_cost"]

                if "id" in data["properties"]:
                    id = data["properties"]["id"]


            return cls(stations, integration_cost=integration_cost, id=id)

        elif data["type"] == "Feature":
            station = GroundStation.from_geojson(data)

            return cls([station], integration_cost=integration_cost)

        else:
            raise RuntimeError(f"Found unsupported GeoJSON type \"{data['type']}\"")

    @classmethod
    def load_geojson_file(cls, f, integration_cost: float = 0.0):
        """
        Load a GroundStationProvider from a GeoJSON file

        Args:
            - f (file): The file to load. Should be a file-pointer to a GeoJSON file.
        """

        data = json.load(f)

        return cls.load_geojson(data, integration_cost=integration_cost)

    def as_brahe_model(self):
        return [sta.as_brahe_model() for sta in self.stations]

    def as_dict(self):
        return {
            "type": "FeatureCollection",
            "features": [sta.as_geojson() for sta in self.stations],
            "properties": {
                "provider": self.provider,
                "id": self.id,
                "integration_cost": self.integration_cost
            }
        }

    def get(self, key: str) -> GroundStation | ValueError:
        """
        Get a specific Ground Station object by ID or name. Returns and error if not found

        :param key: String of either a station ID or name value
        :return: GroundStation
        """

        if key in self._station_id_lookup:
            return self._station_id_lookup[key]
        elif key in self._station_name_lookup:
            return self._station_name_lookup[key]
        else:
            raise ValueError(f"No station with identifier \"{key}\" found in {self.provider} provider.")

    def set_property(self, property: str, value: float, key: str | None = None):
        """
        Set a property for all stations in the provider. If a provider is provided then only stations with that
        provider will be updated.

        Args:
            - property (str): The property to set
            - value (float): The value to set the property to
            - key (str): ID of specific station to update
        """

        if property not in ['cost_per_pass', 'cost_per_minute', 'per_satellite_license_cost', 'monthly_cost', 'setup_cost', 'elevation_min', 'datarate', 'antennas']:
            raise ValueError(f"\"{property}\" is not a settable property")

        if value < 0.0:
            raise ValueError("Property value must be greater than 0")

        # Set single station property if key is provided
        if key:
            setattr(self.get(key), property, value)
        else:
            for sta in self.stations:
                setattr(sta, property, value)

    def __iadd__(self, other: GroundStation):
        """
        Add new ground station to the provider.

        :param other: Ground Station to add to the provider
        :return:
        """
        return self + other

    def __add__(self, other: GroundStation):
        if self.provider is not None and other.provider != self.provider:
            raise RuntimeError("Cannot add ground station from different provider to provider")

        if self.provider is None and other.provider is not None:
            self.provider = other.provider

        # Update data store and lookups
        self.stations.append(other)
        self._station_id_lookup[other.id] = other
        self._station_name_lookup[other.name] = other

        return self

    def __len__(self):
        return len(self.stations)

    def __rich_console__(self, console: Console, options: ConsoleOptions) -> RenderResult:
        tbl = Table(title=f"Provider Information")

        tbl.add_column("Property", justify="left")
        tbl.add_column("Value", justify="left")

        tbl.add_row("Name", self.provider)
        tbl.add_row("Id", self.id)
        tbl.add_row("Number of Stations", str(len(self.stations)))
        tbl.add_row("Integration Cost", f"${self.integration_cost:.2f}")

        yield tbl

class Satellite():
    def __init__(self, satcat_id: str | int, name: str, tle_line1: str, tle_line2: str, id: str = None, datarate: float = 0.0):

        if not satcat_id:
            raise ValueError("Satellite must have a satcat_id")

        if int(satcat_id) < 0:
            raise ValueError("Satellite satcat_id must be greater than 0")

        if not name:
            raise ValueError("Satellite must have a name")

        if not tle_line1:
            raise ValueError("Satellite must have a TLE line 1")

        if not tle_line2:
            raise ValueError("Satellite must have a TLE line 2")

        self.id = id

        if not id:
            self.id = str(uuid.uuid4())

        self.satcat_id = str(satcat_id)
        self.name = name
        self.tle_line1 = tle_line1
        self.tle_line2 = tle_line2

        # Create Internal TLE object

        self.tle = TLE(self.tle_line1, self.tle_line2)

        # Set data rate
        self.datarate = datarate

    @classmethod
    def from_elements(cls, satcat_id: str | int, name: str, epoch: Epoch, sma: float, ecc: float, inc: float, raan: float, argp: float, mean_anomaly: float, is_sso: bool = False, datarate: float = 0.0):
        """
        Initialize Satellite Object from orbital elements

        Args:
            satcat_id: Name of satellite
            name: Name of satellite
            epoch: Epoch of the satellite
            sma: Semi-major axis of the satellite
            ecc: Eccentricity of the satellite
            inc: Inclination of the satellite [deg]
            raan: Right Ascension of the Ascending Node of the satellite [deg]
            argp: Argument of Perigee of the satellite [deg]
            mean_anomaly: Mean Anomaly of the satellite [deg]
            is_sso: Flag to indicate if satellite is in a Sun-Synchronous Orbit, if set inclination will be adjusted to be SSO and inc will be ignored

        Returns: Satellite object
        """

        if is_sso:
            inc = sun_sync_inclination(sma, ecc, use_degrees=True)

        tle_line1, tle_line2 = tle_string_from_elements(
            epoch,
            [
                mean_motion(sma, use_degrees=True) * 86400 / 360,
                # Convert sma into mean motion rev/day
                ecc, inc, raan, argp, mean_anomaly, 0.0, 0.0, 0.0],
            norad_id=int(satcat_id),
        )

        return cls(satcat_id, name, tle_line1, tle_line2, datarate=datarate)

    def as_brahe_model(self):
        return bdm.Spacecraft(
            id=int(self.satcat_id),
            name=self.name,
            line1=self.tle_line1,
            line2=self.tle_line2,
        )

    def as_dict(self):
        """
        Serialize the model into a dictionary. This is needed to avoid serializing the TLE object.
        """
        return {
            'satcat_id': self.satcat_id,
            'tle_line1': self.tle_line1,
            'tle_line2': self.tle_line2,
            'name': self.name,
            'id': self.id,
            'datarate': self.datarate
        }

    @property
    def alt(self):
        return self.tle.a - R_EARTH

    def __str__(self):
        return f"Satellite({self.satcat_id}, {self.name}, {self.tle.a:.3f} km, {self.tle.e:.3f}, {self.tle.i:.3f} deg, {self.tle.RAAN:.3f} deg, {self.tle.w:.3f} deg, {self.tle.M:.3f} deg, {self.datarate*1e-6:.3f} Mbps)"

    def __repr__(self):
        return self.__str__()

    def __rich_console__(self, console: Console, options: ConsoleOptions) -> RenderResult:

        tbl = Table(title=f"{self.name.upper()} Satellite")

        tbl.add_column("Property", justify="left")
        tbl.add_column("Value")

        tbl.add_row("Name", self.name)
        tbl.add_row("Id", str(self.id))
        tbl.add_row("Satcat ID", self.satcat_id)
        tbl.add_row("Epoch", str(self.tle.epoch))
        tbl.add_row("Semi-Major Axis [km]", f"{self.tle.a/1e3:.3f}")
        tbl.add_row("Altitude [km]", f"{(self.tle.a - R_EARTH)/1e3:.3f}")
        tbl.add_row("Eccentricity", f"{self.tle.e:.3f}")
        tbl.add_row("Inclination [deg]", f"{self.tle.i:.3f}")
        tbl.add_row("RAAN [deg]", f"{self.tle.RAAN:.3f}")
        tbl.add_row("Argument of Perigee [deg]", f"{self.tle.w:.3f}")
        tbl.add_row("Mean Anomaly [deg]", f"{self.tle.M:.3f}")
        tbl.add_row("Data Rate [Mbps]", f"{self.datarate * 1e-6:.3f}")

        yield tbl


class Contact():

    def __init__(self, contact: bdm.Contact, station: GroundStation, satellite: Satellite):

        # Set contact properties
        self.id = str(uuid.uuid4())

        # Set Station Values
        self.station_id = station.id
        self.station_name = station.name
        self.provider_id = station.provider_id
        self.provider = station.provider
        self.longitude = station.lon
        self.latitude = station.lat
        self.altitude = station.alt

        # Set Satellite Values
        self.satellite_id = satellite.id
        self.satcat_id = str(satellite.satcat_id)
        self.satellite_name = satellite.name
        self.tle = satellite.tle

        # Set window values
        self.t_start = Epoch(contact.t_start)
        self.t_end = Epoch(contact.t_end)
        self.t_duration = contact.t_duration

        # Set cost values

        self.cost = station.cost_per_pass + self.t_duration/60*station.cost_per_minute
        self.cost_per_pass = station.cost_per_pass
        self.cost_per_minute = station.cost_per_minute

        # Set data transfer values
        self.datarate = min(station.datarate, satellite.datarate) # Get the minimum of the two data rates
        self.data_volume = self.datarate * self.t_duration

    @classmethod
    def from_solution(cls, data, station: GroundStation, satellite: Satellite):
        return cls(data, station, satellite)

    @property
    def lon(self):
        return self.longitude

    @property
    def lat(self):
        return self.latitude

    @property
    def alt(self):
        return self.altitude

    def as_dict(self, minimal: bool = False):

        if minimal:
            return {
                'id': self.id,
                'station_id': self.station_id,
                'provider_id': self.provider_id,
                'satellite_id': self.satellite_id,
                't_start': self.t_start.isoformat(),
                't_end': self.t_end.isoformat(),
                't_duration': self.t_duration,
                'cost': self.cost,
                'cost_per_minute': self.cost_per_minute,
                'cost_per_pass': self.cost_per_pass,
                'datavolume': self.data_volume
            }
        else:
            return {
                'id': self.id,
                'station_id': self.station_id,
                'station_name': self.station_name,
                'provider_id': self.provider_id,
                'provider': self.provider,
                'longitude': self.longitude,
                'latitude': self.latitude,
                'altitude': self.altitude,
                'satellite_id': self.satellite_id,
                'satcat_id': self.satcat_id,
                'satellite_name': self.satellite_name,
                'tle_line1': self.tle.line1,
                'tle_line2': self.tle.line2,
                't_start': self.t_start.isoformat(),
                't_end': self.t_end.isoformat(),
                't_duration': self.t_duration,
                'cost': self.cost,
                'cost_per_pass': self.cost_per_pass,
                'cost_per_minute': self.cost_per_minute,
                'datarate': self.datarate,
                'data_volume': self.data_volume
            }


import os

# Optionally instrument the application with Iudex for monitoring
# See https://iudexai.com/ for more information
if os.getenv('IUDEX_API_KEY'):
    pass
    from iudex import instrument, start_trace, end_trace

    instrument(
        service_name = "GroundStationOptimizer",  # highly encouraged
        env = os.getenv('GSOPT_ENV', 'local'),  # dev, local, etc
        iudex_api_key = os.getenv('IUDEX_API_KEY'),  # only ever commit your WRITE ONLY key
        disable_print=True,
    )

    iudex_token = start_trace(name="GSOpt")

import shutil

from gsopt.utils import filter_warnings
from gsopt.widgets import *

# Filter warnings
filter_warnings()

# Enforce log-level and set log format to include timestamp
logging.basicConfig(
    datefmt='%Y-%m-%dT%H:%M:%S',
    format='%(asctime)s.%(msecs)03dZ %(levelname)s [%(filename)s:%(lineno)d] %(message)s',
    level=logging.INFO
)

st.set_page_config(layout="wide")

st.markdown('''
# Ground Station Optimization

This application allows a user to optimize the selection of ground stations providers and locations for a given
satellite or set of satellites. The application walks the user through defining the stations to consider, the
spacecraft to consider, and the constraints and objectives of the optimization problem. The user can then run the
optimization and view the results.
''')

st.markdown("### Earth Orientation Parameters (EOP) Data")

st.markdown("""
This application needs valid Earth Orientation Parameters (EOP) data to run. The EOP data is used to correctly transform
between different reference frames and time systems. The EOP data must be updated periodically from empirical data
sources. If the data is outdate and does not cover the time period of the optimization, you may need to update the
data by clicking the button below.
""")

# Initialize the EOP data since it normally isn't loaded until the first time it is used
# Check if an EOP file already exists and load it
utils.initialize_eop()


# The bh.EOP data object is the global EOP data object that is used globally in Brahe once loaded. We access the
# internal data object (_data) to get the keys (modified julian date), find the largest key, and then convert that
# key to a calendar date.
max_eop_caldate = bh.mjd_to_caldate(max(bh.EOP._data.keys()))

st_eop_max_date = st.empty()
st_eop_max_date.write(f"EOP Data Valid Through: {max_eop_caldate[0]}-{max_eop_caldate[1]:02d}-{max_eop_caldate[2]:02d}")

# Create a button when clicked that will update the EOP data
if st.button("Update EOP Data"):
    # Download the latest EOP data
    with st.spinner('Updating...'):
        bh.utils.download_iers_bulletin_ab()

    # Move the data to the correct location
    shutil.move("iau2000A_finals_ab.txt", "data/iau2000A_finals_ab.txt")

    # Reload the EOP data
    bh.EOP.load("data/iau2000A_finals_ab.txt")

    # Get the new max date
    max_eop_caldate = bh.mjd_to_caldate(max(bh.EOP._data.keys()))
    st_eop_max_date.write(
        f"EOP Data Valid Through: {max_eop_caldate[0]}-{max_eop_caldate[1]:02d}-{max_eop_caldate[2]:02d}")

# Define Ground Stations
station_selector()

# Define spacecraft
satellite_selector()

st.markdown('## Optimization')

"""
This section allows the user to define the optimization problem by selecting the constraints and objectives for the
problem as well as setting other parameters for the optimization.
"""

downlink_model_selector()

cost_model_selector()

opt_problem_creator_widget()

# Clean Up Iudex Logging
if os.getenv('IUDEX_API_KEY'):
    pass
    end_trace(iudex_token)
'''
This module contains the GSOptimizer class, which is used to solve the ground station optimization problem.
'''
import json
import logging
import os
import time
import copy
from enum import Enum
from itertools import groupby

import pyomo.kernel as pk
import pyomo.opt as po

import brahe as bh

import streamlit as st
from pyomo.common.errors import ApplicationError
from rich.console import Console, ConsoleOptions, RenderResult
from rich.table import Table
from rich.text import Text

import matplotlib.pyplot as plt
import matplotlib.patches as mpatches

from gsopt.plots import plot_stations, select_color

from gsopt import utils
from gsopt.milp_constraints import GSOptConstraint
from gsopt.milp_core import ProviderNode, StationNode, ContactNode, SatelliteNode
from gsopt.models import GroundStation, Satellite, OptimizationWindow, DataUnits
from gsopt.optimizer import GroundStationOptimizer
from gsopt.utils import APPLIED_FILTER_WARNINGS

logger = logging.getLogger()


# Enumeration of available optimizers
class OptimizerType(Enum):
    Gurobi = 'gurobi'
    Scip = 'scip'
    Cbc = 'cbc'
    Glpk = 'glpk'

def get_optimizer(optimizer: str) -> OptimizerType:
    """
    Get the optimizer type from a string

    Args:
        optimizer (str): Optimizer string

    Returns:
        OptimizerType: Optimizer type
    """

    if optimizer.lower() == 'gurobi':
        return OptimizerType.Gurobi
    if optimizer.lower() == 'scip':
        return OptimizerType.Scip
    elif optimizer.lower() == 'glpk':
        return OptimizerType.Glpk
    elif optimizer.lower() == 'cbc':
        return OptimizerType.Cbc
    else:
        raise ValueError(f"Unsupported optimizer: {optimizer}")

def check_solver(optimizer: str | OptimizerType) -> bool:

    # Convert type to string if necessary
    if isinstance(optimizer, OptimizerType):
        optimizer = optimizer.value
    
    if optimizer.lower() == 'gurobi':
        return po.SolverFactory("gurobi").available()
    elif optimizer.lower() == 'scip':
        return po.SolverFactory("scip", executable=os.popen('which scip').read().strip()).available()
    elif optimizer.lower() == 'glpk':
        return po.SolverFactory("glpk").available()
    elif optimizer.lower() == 'cbc':
        return po.SolverFactory("cbc").available()
    else:
        raise ValueError(f"Unsupported optimizer: {optimizer}")


# MILP Optimizer
class MilpOptimizer(pk.block, GroundStationOptimizer):
    """
    A MILP optimizer defines
    """

    def __init__(self, opt_window: OptimizationWindow, optimizer: OptimizerType = OptimizerType.Cbc, presolve: int | None = 1):
        # Initialize parent classes
        pk.block.__init__(self)
        GroundStationOptimizer.__init__(self, opt_window)

        # Set optimizer
        self.optimizer = optimizer
        self.presolve = presolve

        # Define MILP objective
        self.obj_block = pk.block()

        # Variables
        self.provider_nodes = pk.block_dict()
        self.station_nodes = pk.block_dict()
        self.contact_nodes = pk.block_dict()
        self.satellite_nodes = pk.block_dict()
        self.station_satellite_nodes = pk.variable_dict()

        # Constraints container
        self.constraint_blocks = pk.block_list()
        self.constraints = pk.constraint_list()

        # Metadata
        self.n_vars = {
            'providers': 0,
            'stations': 0,
            'contacts': 0,
            'satellites': 0,
            'station_sat_indicators': 0
        }
        self.n_constraints = 0

        self._problem_initialized = False
        self._objective_set = False

        # Confirm the selected solver is available
        if not check_solver(optimizer):
            raise RuntimeError(f"Selected solver {optimizer} is not available. Please select a different solver.")

    @property
    def opt_start(self):
        return copy.deepcopy(self.opt_window.opt_start)

    @property
    def opt_end(self):
        return copy.deepcopy(self.opt_window.opt_end)

    @property
    def sim_start(self):
        return copy.deepcopy(self.opt_window.sim_start)

    @property
    def sim_end(self):
        return copy.deepcopy(self.opt_window.sim_end)

    def set_objective(self, objective):
        """
        Set the objective function for the optimization problem

        Args:
            objective (pk.objective): Objective function to set
        """

        if isinstance(objective, pk.block):

            # Always remove the old objective block
            del self.obj_block

            self.obj_block = objective

        elif isinstance(objective, pk.objective):
            raise ValueError("Objective must be a block type. Use a block with a member varible that is a pyomo.kernel.objective")

        else:
            raise ValueError(f"Objective must be of type pk.block. Unsupported type: {type(objective)}")

        self._objective_set = True

    def add_constraint(self, constraint):
        """
        Add / apply a constraint set to the model instance

        Args:
            constraint (pk.constraints): Constraint to add to the model
        """

        if isinstance(constraint, list) and len(constraint) != 1:
            raise ValueError("Input constraint must be a single constraint, not a list of constraints")

        if isinstance(constraint, pk.block):
            self.constraint_blocks.append(constraint)

        elif isinstance(constraint, (pk.constraint, pk.constraint_list, pk.constraint_dict)):
            self.constraints.append(constraint)
        else:
            raise ValueError(f"Constraint {type(constraint).__name__} is not of type pk.constraint, pk.constraint_list, or pk.constraint_dict")

    def add_constraints(self, constraints: list):
        """
        Add / apply a list of constraints to the model instance

        Args:
            constraints (list[pk.constraint]): List of constraints to add to the model
        """

        for constraint in constraints:
            self.add_constraint(constraint)

    def generate_nodes(self):
        """
        Create the nodes for the MILP model
        """


        # Generate provider nodes
        for id, provider in self.providers.items():
            self.provider_nodes[id] = ProviderNode(**{'obj': provider})
            self.n_vars['providers'] += 1

        for id, station in self.stations.items():
            self.station_nodes[id] = StationNode(**{'obj': station, 'provider': self.providers[station.provider_id]})
            self.n_vars['stations'] += 1

        for id, satellite in self.satellites.items():
            self.satellite_nodes[id] = SatelliteNode(**{'obj': satellite})
            self.n_vars['satellites'] += 1

        for id, contact in self.contacts.items():
            self.contact_nodes[id] = ContactNode(**{'obj': contact,
                                                            'provider': self.providers[contact.provider_id],
                                                            'station': self.stations[contact.station_id],
                                                            'satellite': self.satellites[contact.satellite_id]})
            self.n_vars['contacts'] += 1

        # Generate station_statellite individuals
        for station_id in self.stations:

            # Get all statellites that had a contact with the station
            sat_ids = set([c.satellite_id for c in self.contacts.values() if c.station_id == station_id])

            for s in sat_ids:
                self.station_satellite_nodes[(station_id, s)] = pk.variable(value=0, domain=pk.Binary)

                self.n_vars['station_sat_indicators'] += 1


    def generate_problem(self):
        """
        Build the underlying MILP objetive and constraints
        """

        if not self._objective_set:
            raise RuntimeError("Objective function not set. Please set the objective function before generating the problem.")

        logger.info("Generating MILP problem...")
        ts = time.perf_counter()

        # Generate nodes to ensure variables exist
        self.generate_nodes()

        inputs = dict(
            provider_nodes=self.provider_nodes,
            station_nodes=self.station_nodes,
            contact_nodes=self.contact_nodes,
            satellite_nodes=self.satellite_nodes,
            station_satellite_nodes=self.station_satellite_nodes,
            opt_window=self.opt_window
        )

        # Generate constraints
        for constraint in self.constraint_blocks:
            if hasattr(constraint, '_generate_constraints'):
                constraint._generate_constraints(**inputs)
            self.n_constraints += len(constraint.constraints)

        for constraint in self.constraints:
            if hasattr(constraint, '_generate_constraints'):
                constraint._generate_constraints(**inputs)
            self.n_constraints += len(constraint)

        # Generate objective function
        # We do this after the constraints since some objectives (MinMaxContactGapObjective) require additional
        # constraints to be generated, and it's nicer for debugging if all user-specified constraints are generated first
        self.obj_block._generate_objective(**inputs)

        # Generate minimum variable constraints
        # This must be done after the constraints are generated for the model
        self._generate_variable_constraints()

        te = time.perf_counter()
        self.problem_setup_time = te - ts
        logger.info(f"Finished generating MILP problem with {self.n_constraints} constraints. Took: {utils.get_time_string(te - ts)}.")

    def _generate_variable_constraints(self):
        """
        Generate variable relationship constraints for indicator variables. This enforces that
        if any station is selected, the corresponding satellite-station indicator variable is set.
        It also enforces that the indicator that if a station is used that station and provider are also indicated as
        used.
        """

        # If a single contact for a given station is selected then that station must be selected
        contact_nodes_sorted = sorted(self.contact_nodes.values(), key=lambda x: x.station.id)
        for gs_id, contacts in groupby(contact_nodes_sorted, key=lambda x: x.station.id):
            contact_node_group = list(contacts)
            num_station_contacts = len(contact_node_group)

            # logger.debug(f'Generating constraints for station {gs_id} with {num_station_contacts} contacts')

            # Ensure that station node is scheduled if at least one contact is scheduled
            self.constraints.append(pk.constraint(
                sum([self.contact_nodes[c.id].var for c in contact_node_group]) <= num_station_contacts * self.station_nodes[gs_id].var
            ))

            # Ensure at least one contact is scheduled if station is scheduled
            self.constraints.append(pk.constraint(
                sum([self.contact_nodes[c.id].var for c in contact_node_group]) >= self.station_nodes[gs_id].var
            ))

            self.n_constraints += 1

            # If a single contact for a given satellite is selected then that satellite-station indicator must be selected
            contacts_by_satellite_sorted = sorted(contact_node_group, key=lambda x: str(x.satellite.id))
            for sat_id, sat_contacts in groupby(contacts_by_satellite_sorted, key=lambda x: x.satellite.id):
                sat_contact_group = list(sat_contacts)
                num_sat_contacts = len(sat_contact_group)

                # logger.debug(f'Generating constraints for station {gs_id}, for satellite {sat_id}, with {num_sat_contacts} contacts')

                self.constraints.append(pk.constraint(
                    sum([self.contact_nodes[c.id].var for c in sat_contact_group]) <= num_sat_contacts * self.station_satellite_nodes[(gs_id, sat_id)]
                ))

                self.n_constraints += 1

        # If a single station for a given provider is selected then that provider must be selected
        station_nodes_sorted = sorted(self.station_nodes.values(), key=lambda x: x.provider.id)
        for p_id, stations in groupby(station_nodes_sorted, key=lambda x: x.provider.id):
            station_node_group = list(stations)
            num_provider_stations = len(station_node_group)

            # logger.debug(f'Generating constraints for provider {p_id} with {num_provider_stations} stations')

            self.constraints.append(pk.constraint(
                sum([self.station_nodes[s.id].var for s in station_node_group]) <= num_provider_stations * self.provider_nodes[p_id].var
            ))

            self.n_constraints += 1


    def solve(self):

        # Initialize problem
        if not self._problem_initialized:
            self.generate_problem()
            self._problem_initialized = True

        logger.info(f"Solving MILP problem using the {self.optimizer.value.capitalize()} solver...")
        ts = time.perf_counter()

        # Select solver
        if self.optimizer == OptimizerType.Gurobi:
            logger.debug("Using Gurobi solver")
            solver = po.SolverFactory("gurobi")

        elif self.optimizer == OptimizerType.Scip:
            logger.debug("Using SCIP solver")
            solver = po.SolverFactory("scip", executable=os.popen('which scip').read().strip())

        elif self.optimizer == OptimizerType.Glpk:
            logger.debug("Using GLPK solver")
            solver = po.SolverFactory("glpk")

        else:
            logger.debug("Using backup Coin-OR Cbc solver")
            solver = po.SolverFactory("cbc")

            # Set timeout limit on solve
            if self.time_limit is not None:
                solver.options['TimeLimit'] = self.time_limit
            if self.presolve is not None:
                if self.presolve not in [0, 1, 2]:
                    raise ValueError("Presolve must be 0, 1, or 2")
                solver.options['Presolve'] = self.presolve

        try:
            self.solution = solver.solve(self, tee=self.verbose)
        except ApplicationError as e:
            logger.error(f"Solver error: {e}")

        # Set solver status
        self.solver_status = str(self.solution.solver.termination_condition)


        te = time.perf_counter()
        self.solve_time = te - ts

        logger.info(f"Solved MILP problem in {utils.get_time_string(self.solve_time)} with status: {self.solver_status}")


    def get_solution(self):
        """
        Get the solution from the MILP solver

        Returns:
            - Solver status
            - Compute time
            - Objective value
            - Provider selection
            - Station selection
            - Contact selection
        """

        solution = {}

        # Compute statistics
        solution['runtime'] = {
            'contact_compute_time': self.contact_compute_time,
            'problem_setup_time': self.problem_setup_time,
            'solve_time': self.solve_time,
        }

        # Problem Formulation
        solution['problem'] = {
            'objective': self.obj_block.dict(),
            'constraints': [c.dict() for c in self.constraint_blocks if isinstance(c, GSOptConstraint)]
        }

        # Solution Output
        solution['solver_status'] = self.solver_status.upper()

        # Objective value
        solution['objective_value'] = self.obj_block.obj()

        # Solution Metadata
        solution['n_vars'] = self.n_vars
        solution['n_constraints'] = self.n_constraints

        # Compute Costs
        total_cost = 0.0
        total_fixed_cost = 0.0
        total_operational_cost = 0.0
        monthly_operational_cost = 0.0

        ## Provider Costs - Fixed
        for pn_id, pn in self.provider_nodes.items():
            if pn.var() > 0:
                total_cost += pn.model.integration_cost
                total_fixed_cost += pn.model.integration_cost

        ## Station Costs - Fixed & Operational
        for sn_id, sn in self.station_nodes.items():
            if sn.var() > 0:
                total_cost += sn.model.setup_cost
                total_fixed_cost += sn.model.setup_cost

                extr_opt_cost = (12 * self.opt_window.T_opt) / (365.25 * 86400.0 * self.opt_window.T_sim) * sn.model.monthly_cost
                total_cost += extr_opt_cost
                total_operational_cost += extr_opt_cost
                monthly_operational_cost += sn.model.monthly_cost

        ## Add Satellite Licensing Costs
        for (station_id, sat_id) in self.station_satellite_nodes.keys():
            if self.station_satellite_nodes[(station_id, sat_id)]() > 0:
                total_cost += self.station_nodes[station_id].model.per_satellite_license_cost

        ## Contact Costs - Operational
        for cn_id, cn in self.contact_nodes.items():
            if cn.var() > 0:
                total_cost += self.opt_window.T_opt / self.opt_window.T_sim * cn.model.cost
                total_operational_cost += self.opt_window.T_opt / self.opt_window.T_sim * cn.model.cost
                monthly_operational_cost += cn.model.cost / self.opt_window.T_sim * (365.25 * 86400.0) / 12.0

        # Data Downlink Statistics
        total_data_downlinked = sum(
            [c.model.data_volume  for c in self.contact_nodes.values() if c.var() > 0]) * self.opt_window.T_opt / self.opt_window.T_sim

        datavolume_by_satellite = {
            'total': {},
            'total_GB': {},
            'daily_avg': {},
            'daily_avg_GB': {}
        }

        for sat_id, sat_contacts in groupby(self.contact_nodes.values(), lambda c: c.model.satellite_id):
            datavolume_by_satellite['total'][sat_id] = sum([c.model.data_volume for c in
                                                            sat_contacts]) * self.opt_window.T_opt / self.opt_window.T_sim
            datavolume_by_satellite['total_GB'][sat_id] = datavolume_by_satellite['total'][sat_id] / DataUnits.GB.value
            datavolume_by_satellite['daily_avg'][sat_id] = datavolume_by_satellite['total'][sat_id] / (
                        self.opt_window.T_opt / 86400.0)
            datavolume_by_satellite['daily_avg_GB'][sat_id] = datavolume_by_satellite['daily_avg'][sat_id] / DataUnits.GB.value

        solution['statistics'] = {
            'costs': {
                'total': total_cost,
                'fixed': total_fixed_cost,
                'operational': total_operational_cost,
                'monthly_operational': monthly_operational_cost,
            },
            'data_downlinked': { # Value values in bits
                'total': total_data_downlinked,
                'total_GB': total_data_downlinked / DataUnits.GB.value,
                'by_satellite': datavolume_by_satellite,
            },
            'contact_time_s': {
                'total': sum([c.model.t_duration for c in self.contact_nodes.values() if c.var() > 0]) * self.opt_window.T_opt / self.opt_window.T_sim,
                'by_satellite': {sat_id: sum([c.model.t_duration * c.var() for c in sat_contacts]) / (self.opt_window.T_sim / 86400.0) for sat_id, sat_contacts in groupby(self.contact_nodes.values(), lambda c: c.model.satellite_id)}
            }
        }

        # Optimization Window
        solution['optimization_window'] = self.opt_window.as_dict()

        # Satellites
        solution['satellites'] = [sn.model.as_dict() for sn in self.satellite_nodes.values()]

        # Variable selection
        solution['providers'] = [pn.model.as_dict() for pn in self.provider_nodes.values()]
        solution['selected_providers'] = [pn.model.name for pn in self.provider_nodes.values() if pn.var() > 0]
        solution['selected_stations'] = [{'name': sn.model.name, 'provider': sn.model.provider} for sn in self.station_nodes.values() if sn.var() > 0]
        solution['contacts'] = [cn.model.as_dict(minimal=True) for cn in sorted(self.contact_nodes.values(), key=lambda c: c.model.t_start) if cn.var() > 0]

        # Add station-satellite indicators
        solution['stations_by_satellite'] = {}

        for sat_id, sat in self.satellites.items():
            solution['stations_by_satellite'][sat_id] = []
            for gs_id, gs in self.stations.items():
                if (gs_id, sat_id) in self.station_satellite_nodes and \
                    self.station_satellite_nodes[(gs_id, sat_id)]() > 0:
                    solution['stations_by_satellite'][sat_id].append(gs_id)

        return solution

    def write_solution(self, filename: str):
        """
        Write the solution to a file

        Args:
            filename (str): Filename to write the solution to
        """

        # Confirm problem has been solved
        if self.solver_status == 'Not Solved':
            raise RuntimeError("Problem has not been solved. Please solve the problem before writing the solution.")

        # Confirm filename is a JSON file
        if not filename.endswith('.json'):
            raise ValueError("Filename must be a JSON file (e.g. 'single_sat_solution.json')")

        json.dump(self.get_solution(), open(filename, 'w'), indent=4)

    def __str__(self):
        return f"<MilpOptimizer - {self.solver_status}: {len(self.satellites)} satellites, {len(self.providers)} providers, {len(self.stations)} stations, {len(self.contacts)} contacts>"

    def __rich_console__(self, console: Console, options: ConsoleOptions) -> RenderResult:

        tbl = Table(title="MILP Optimizer")

        tbl.add_column("Property")
        tbl.add_column("Value")

        tbl.add_row("Optimization Objective", self.obj_block.__class__.__name__)
        tbl.add_row("Contact Compute Time", utils.get_time_string(self.contact_compute_time))
        tbl.add_row("# of Satellites", str(len(self.satellites)))
        tbl.add_row("# of Providers", str(len(self.providers)))
        tbl.add_row("# of Stations", str(len(self.stations)))
        tbl.add_row("# of Contacts", str(len(self.contacts)))
        tbl.add_row("# of Variables:", str(sum(self.n_vars.values())))
        tbl.add_row("- Satellites", str(self.n_vars['satellites']))
        tbl.add_row("- Satellite Station Indicators", str(self.n_vars['station_sat_indicators']))
        tbl.add_row("- Providers", str(self.n_vars['providers']))
        tbl.add_row("- Stations", str(self.n_vars['stations']))
        tbl.add_row("- Contacts", str(self.n_vars['contacts']))
        tbl.add_row("Number of Constraints", str(self.n_constraints))
        tbl.add_row("Setup Time", str(utils.get_time_string(self.problem_setup_time)))
        tbl.add_row("Solver Status", str(self.solver_status).upper())
        tbl.add_row("Solve Time", utils.get_time_string(self.solve_time))
        tbl.add_row("Objective Value", str(self.obj_block.obj()))
        tbl.add_row("# of Selected Providers", str(sum([pn.var() for pn in self.provider_nodes.values()])))
        for provider in self.provider_nodes.values():
            if provider.var() > 0:
                text = Text("Yes")
                text.stylize("bright_green", 0, 4)
            else:
                text = Text("No")
                text.stylize("bright_red", 0, 2)

            tbl.add_row(f" - {provider.model.name}", text)

        tbl.add_row("# of Selected Stations", str(sum([sn.var() for sn in self.station_nodes.values()])))

        for _, station_groups in groupby(sorted(self.station_nodes.values(), key=lambda x: x.provider.name),
                                         lambda x: x.provider.name):
            for s in station_groups:
                if s.var() > 0:
                    text = Text("Yes")
                    text.stylize("bright_green", 0, 4)
                else:
                    text = Text("No")
                    text.stylize("bright_red", 0, 2)
                tbl.add_row(f" - {s.provider.name}-{s.model.name}", text)

        tbl.add_row("# of Selected Contacts", str(sum([cn.var() for cn in self.contact_nodes.values()])))

        yield tbl

    def set_presolve(self, presolve: int):
        """
        Set the presolve level for the solver

        Args:
            presolve (int): Presolve level (0, 1, 2)
        """
        self.presolve = presolve

    def save_plot(self, filepath='station_selection.png', legend: bool = True):
        """
        Plot the ground stations on a map.
        - If the optimizer hasn't been solved yet, plot all stations.
        - If the optimizer has been solved, plot only the selected stations.
        
        Args:
            filepath (str): Path to save the plot. Default is 'station_selection.png'.
        
        Returns:
            tuple: Figure and axes objects for further customization.
        """
        # Determine which stations to plot based on solver status
        if self.solver_status == 'Not Solved':
            # Plot all stations if not solved
            stations_to_plot = []
            for provider_id, provider in self.providers.items():
                for station in provider.stations:
                    stations_to_plot.append((station.lon, station.lat, station.provider))
            title = "All Available Ground Stations"
        else:
            # Plot only selected stations if solved
            stations_to_plot = []
            for sn_id, sn in self.station_nodes.items():
                if sn.var() > 0:  # This station is selected
                    station = self.stations[sn_id]
                    stations_to_plot.append((station.lon, station.lat, station.provider))
            title = "Selected Ground Stations"
        
        # Get minimum elevation angle and altitude from satellites
        elevation_min = min([station.elevation_min for station in self.stations.values()]) if self.stations else 10.0
        altitude = min([sat.alt for sat in self.satellites.values()]) if self.satellites else 500e3
        
        # Plot the stations
        fig, ax = plot_stations(stations_to_plot, elevation_min=elevation_min, alt=altitude)
        
        # Add title and customize plot
        plt.title(title)
        
        # Add a legend of providers
        if legend:
            providers = set(station[2] for station in stations_to_plot)
            patches = []
            for provider in providers:
                color = select_color(provider)
                patch = mpatches.Patch(color=color, label=provider, alpha=0.5)
                patches.append(patch)
            if patches:
                plt.legend(handles=patches, loc='lower left')
        
        # Save the figure
        plt.savefig(filepath, dpi=300, bbox_inches='tight')
        
        return fig, ax'''
This module contains the base GroundStationOptimizer class, which allows for the definition of
the problem of ground station selection and optimization.
'''
import time
import multiprocessing as mp
import brahe as bh
from enum import Enum
from pathlib import Path

from brahe import Epoch
from rich.console import Console, ConsoleOptions, RenderResult
from rich.table import Table
import logging
from abc import abstractmethod, ABCMeta

from gsopt import utils
from gsopt.models import GroundStation, GroundStationProvider, Satellite, OptimizationWindow

logger = logging.getLogger()

class GroundStationOptimizer(metaclass=ABCMeta):

    def __init__(self, opt_window: OptimizationWindow, verbose: bool = False, time_limit: float | None = None):
        super().__init__()

        self.verbose = verbose
        self.time_limit = time_limit

        self.opt_window = opt_window

        # Problem inputs
        self.satellites = {}
        self.providers = {}
        self.stations = {}

        # Working variables
        self.contacts = {}

        # Common optimization problem variables
        self.solver_status = 'Not Solved'
        self.solve_time = 0.0
        self.contact_compute_time = 0.0
        self.problem_setup_time = 0.0

    def add_satellite(self, satellite: Satellite):
        self.satellites[satellite.id] = satellite

    def add_provider(self, provider: GroundStationProvider):
        """
        Add a station provider to the optimizer.
        """
        self.providers[provider.id] = provider

        for station in provider.stations:
            self.stations[station.id] = station

    @classmethod
    def from_scenario(cls, scenario, optimizer = None, presolve: int | None = 1):
        """
        Create a GroundStationOptimizer from a ScenarioGenerator object.
        """
        opt_window = scenario.opt_window
        if optimizer is not None:
            optimizer = cls(opt_window, optimizer=optimizer, presolve=presolve)
        else:
            optimizer = cls(opt_window)

        for sat in scenario.satellites:
            optimizer.add_satellite(sat)

        for provider in scenario.providers:
            optimizer.add_provider(provider)

        return optimizer

    @property
    def provider_ids(self):
        return list(self.providers.keys())

    @property
    def station_ids(self):
        return list(self.stations.keys())

    @property
    def satellite_ids(self):
        return list(self.satellites.keys())

    def compute_contacts(self):
        """
        Compute all contacts between the satellites and ground stations.
        """

        # Get contact computation window times
        t_start = Epoch(self.opt_window.sim_start)
        t_end = Epoch(self.opt_window.sim_end)

        t_duration = t_end - t_start

        logger.info(f"Computing contacts for {len(self.satellites)} satellites and {len(self.providers)} providers, {len(self.stations)} stations, over {utils.get_time_string(t_duration)} period...")

        ts = time.perf_counter()

        # Check that the simulation window is within the EOP
        utils.initialize_eop() # Ensure EOP is initialized before checking
        if t_end.mjd() > max(bh.EOP._data.keys()):
            msg = f"Simulation end time {self.opt_window.sim_end} ({self.opt_window.sim_end.mjd()}) is after the EOP end time {max(bh.EOP._data.keys())}"
            logger.error(msg)
            raise RuntimeError(msg)

        # Generate work
        tasks = []
        for station in self.stations.values():
            for sc in self.satellites.values():
                tasks.append((station, sc, t_start, t_end))

        # Compute contacts
        mpctx = mp.get_context('fork')
        with mpctx.Pool(mp.cpu_count()) as pool:

            results = pool.starmap(utils.compute_contacts, tasks)

            for r in results:
                # convert result back to Contact objects

                for c in r:
                    self.contacts[c.id] = c

        te = time.perf_counter()

        self.contact_compute_time = te - ts
        logger.info(f"Contacts computed successfully. Found {len(self.contacts)} contacts. Took {utils.get_time_string(self.contact_compute_time)}.")

    def contact_list(self):
        """
        Return a list of contacts.
        """
        return list(self.contacts.values())

    @abstractmethod
    def solve(self):
        pass

    @abstractmethod
    def write_solution(self, output_file: Path):
        pass

    def set_access_constraints(self, elevation_min: float):
        """
        Set the minimum elevation angle for a contact to be considered.
        """

        for provider in self.providers:
            provider.set_property('elevation_min', elevation_min)

    def __rich_console__(self, console: Console, options: ConsoleOptions) -> RenderResult:
        raise NotImplementedError

    def set_verbose(self, verbose: bool):
        self.verbose = verbose

    def set_time_limit(self, time_limit: float):
        self.time_limit = time_limit
import os
import pathlib
import datetime
import json
import io
import logging

import brahe as bh
import polars as pl
import streamlit as st

from gsopt import utils
from gsopt.ephemeris import get_satcat_df
from gsopt.models import GroundStationProvider, GroundStation, Satellite, Contact, OptimizationWindow
import gsopt.plots as plots

from gsopt.milp_optimizer import MilpOptimizer

logger = logging.getLogger()

# Constants of interest
ALL_FREQUENCIES = ['uhf', 'l', 's', 'x', 'ka']
CONSTELLATIONS = sorted(['YAM', 'UMBRA', 'SKYSAT', 'ICEYE', 'FLOCK', 'HAWK', 'CAPELLA', 'LEGION', 'WORLDVIEW', 'GEOEYE',
                  'NUSAT'])


# Get provider names as file names from ./data/groundstations
def get_providers():
    providers = []

    for file in os.listdir('./data/groundstations'):
        if file.endswith('.json'):
            providers.append(file.replace('.json', ''))

    return providers


def freq_enabled(freq_list: list[str]):
    # Get list of required frequencies
    required_freq = set(freq for freq in ALL_FREQUENCIES if st.session_state[f'{freq.lower()}_enabled'])

    # Check that the required frequencies are a subset of the frequencies supported by the station
    return required_freq <= set([f.lower() for f in freq_list])


def add_provider_selector(provider: str):
    # Create Markdown
    provider_enabled = st.checkbox(f'**{provider.capitalize()}**', value=True)

    # Load Station File
    geojson = json.load(open(pathlib.Path(f'./data/groundstations/{provider}.json'), 'r'))

    stations = []

    cols = st.columns(5)

    if 'features' not in geojson:
        st.error('GeoJSON file must contain a "features" key.')
    else:
        for idx, feature in enumerate(geojson['features']):

            # We'll do some optimistic parsing here because we control the schema
            try:
                name = feature['properties']['name']
                provider = feature['properties']['provider']
                lon, lat = feature['geometry']['coordinates'][:2]
                alt = feature['geometry']['coordinates'][2] if len(feature['geometry']['coordinates']) > 2 else 0.0
                frequency_bands = feature['properties']['frequency_bands']
            except KeyError:
                st.error(f'Feature {idx} does not contain the required fields.')
                continue

            stations.append((
                cols[idx % 5].checkbox(f'{name.capitalize()}', key=f'checkbox_{provider}_{name}',
                                       value=freq_enabled(frequency_bands) and provider_enabled,
                                       disabled=not (freq_enabled(frequency_bands)) and provider_enabled),
                name,
                provider,
                lon,
                lat,
                alt
            ))

    return stations


def contact_list_to_dataframe(contacts: list[Contact]):
    # Create a list of  dictionaries to hold the contact data
    contact_dicts = []

    # Iterate over the contacts and extract the relevant data
    for contact in contacts:
        contact_dicts.append({
            "id": contact.id,
            "location_id": contact.station_id,
            "location_name": contact.name,
            "satellite_id": contact.satellite_id,
            "sattellite_name": contact.satellite_name,
            'longitude': contact.lon,
            'latitude': contact.lat,
            'altitude': contact.alt,
            "t_start": contact.t_start.to_datetime(),
            "t_end": contact.t_end.to_datetime(),
            "t_duration": contact.t_duration,
        })

    # Convert the list of dictionaries to a Polars DataFrame
    return contact_dicts


def ground_stations_from_dataframe(df: pl.DataFrame) -> list[GroundStation]:
    """
    Create a list of GroundStation objects from a Polars DataFrame
    """
    stations = []
    for sta in df.iter_rows(named=True):
        stations.append(GroundStation(
            name=sta['name'],
            provider=sta['provider'],
            longitude=sta['longitude'],
            latitude=sta['latitude'],
            altitude=sta['altitude']
        ))

    return stations

def satellites_from_dataframe(df: pl.DataFrame) -> list[Satellite]:
    """
    Create a list of Satellite objects from a Polars DataFrame
    """
    satellites = []
    for _, sat in enumerate(df.iter_rows(named=True)):
        satellites.append(Satellite(
            # id=idx,
            satcat_id=sat['satcat_id'],
            name=sat['object_name'],
            tle_line1=sat['tle_line1'],
            tle_line2=sat['tle_line2']
        ))

    return satellites


def station_selector():
    st.markdown('## Ground Station Selection')

    st.markdown('''
    This section allows the user to select the ground stations providers and ground stations to consider in the 
    optimization problem. The user can also upload a GeoJSON file with ground station locations or define a custom
    ground station.
    ''')

    if 'stations_df' not in st.session_state:
        st.session_state['stations_df'] = pl.DataFrame({}, schema={
            'name': str,
            'provider': str,
            'longitude': float,
            'latitude': float,
            'altitude': float,
        })

    # Predefined providers

    st.markdown('### Add Stations by Provider')

    st.markdown('This section allows you to select ground stations from predefined providers. The providers are defined'
                'based on current major station providers.')

    st.markdown('**Frequency Bands**')

    st.markdown('Required frequency bands. Enable the checkbox to only consider stations that support the given '
                'frequency bands. If no boxes are checked all stations will be considered (if enabled).')

    freq_columns = st.columns(5)

    st.session_state['uhf_enabled'] = freq_columns[0].checkbox('UHF', value=False)
    st.session_state['l_enabled'] = freq_columns[1].checkbox('L', value=False)
    st.session_state['s_enabled'] = freq_columns[2].checkbox('S', value=False)
    st.session_state['x_enabled'] = freq_columns[3].checkbox('X', value=False)
    st.session_state['ka_enabled'] = freq_columns[4].checkbox('Ka', value=False)

    station_buttons = []
    for provider in sorted(get_providers()):
        station_buttons.extend(add_provider_selector(provider))

    if st.button('Add Stations'):
        for station in station_buttons:
            if station[0]:
                new_loc = pl.DataFrame({
                    'name': station[1],
                    'provider': station[2],
                    'longitude': station[3],
                    'latitude': station[4],
                    'altitude': station[5]
                })

                st.session_state['stations_df'] = pl.concat([st.session_state['stations_df'], new_loc]).unique()

    # Custom Ground Station

    st.markdown('### Add Station by Coordinates')

    st.markdown('This section allows you to define a custom ground station by providing the coordinates and metadata.'
                'The provider name is required to enable optimization of provider selection.')

    name = st.text_input('Station Name')
    provider = st.text_input('Provider Name')
    lon = st.number_input('Longitude (deg)', min_value=-180.0, max_value=180.0, value=0.0, format='%.3f')
    lat = st.number_input('Latitude (deg)', min_value=-90.0, max_value=90.0, value=0.0, format='%.3f')
    alt = st.number_input('Altitude (m)', value=0.0, format='%.3f')

    if st.button('Add Location'):
        if name == '':
            st.error('Please provide a name for the station')

        if provider == '':
            st.error('Please provide a provider name for the station')

        else:
            new_loc = pl.DataFrame({
                'name': name,
                'provider': provider,
                'longitude': lon,
                'latitude': lat,
                'altitude': alt
            })

            st.session_state['stations_df'] = pl.concat([st.session_state['stations_df'], new_loc]).unique()

    # Add button to load locations from GeoJSON
    st.markdown('### Add Stations from GeoJSON')

    st.markdown('Here you can upload a GeoJSON file to define a set of ground stations. The GeoJSON file must adhere to'
                'a predefined schema. An example schema is provided below:')
    with st.expander("GeoJSON Schema"):
        st.code("""
        {
          "type": "FeatureCollection",
          "features": [
            {
              "type": "Feature",
              "geometry": {
                "type": "Point",
                "coordinates": [
                  -0.3, # Longitude [deg]
                  5.6,  # Latitude [deg]
                  0.0   # Altitude [m], Optional
                ]
              },
              "properties": {
                "name": "MyAwesomeStation",
                "provider": "MyAwesomeProvider"
              }
            }
          ]
        }
    """)

    st_geojson_cols = st.columns(2)

    with st_geojson_cols[0]:
        name_property_field = st.text_input('Station Name Property Field', value='',
                                                    help='The field in the GeoJSON file that contains the station name, if any')

    with st_geojson_cols[1]:
        provider_property_field = st.text_input('Provider Name Property Field', value='',
                                                     help='The field in the GeoJSON file that container the provider name, if any')
    geojson_file = st.file_uploader('Upload GeoJSON File', accept_multiple_files=False)

    if st.button('Add Locations from GeoJSON FeatureCollection'):
        if geojson_file is None:
            st.error('Please upload a GeoJSON file.')
        else:
            geojson = json.load(geojson_file)
            if 'features' not in geojson:
                st.error('GeoJSON file must contain a "features" key.')
            else:
                for idx, feature in enumerate(geojson['features']):
                    if 'geometry' in feature and 'coordinates' in feature['geometry']:
                        lon, lat = feature['geometry']['coordinates'][:2]

                        if 'properties' not in feature:
                            st.error(f'Feature {idx} does not contain a "properties" field.')
                            break

                        if 'provider' in feature['properties']:
                            st.error(f'Feature {idx} does not contain a "provider" field.')

                        if 'properties' in feature and name_property_field in feature['properties']:
                            name = feature['properties'][name_property_field]
                        else:
                            name = f"GeoJSON Point ({lon:.3f}, {lat:.3f})"

                        if 'properties' in feature and provider_property_field in feature['properties']:
                            provider = feature['properties'][provider_property_field]
                        else:
                            provider = f"GeoJSON File"

                        alt = feature['geometry']['coordinates'][2] if len(
                            feature['geometry']['coordinates']) > 2 else 0.0

                        new_loc = pl.DataFrame({
                            'name': name,
                            'provider': provider,
                            'longitude': float(lon),
                            'latitude': float(lat),
                            'altitude': float(alt)
                        })

                        st.session_state['stations_df'] = pl.concat([st.session_state['stations_df'], new_loc]).unique()

    # Show all selected locations
    st.markdown('### Selected Stations')

    selected_loc_count = st.empty()
    selected_loc_count.markdown(f"**Number of Locations:** {st.session_state['stations_df'].height}")
    selected_locs = st.empty()
    selected_locs.dataframe(st.session_state['stations_df'].to_pandas())

    selected_loc_row = st.number_input('Selected location index', min_value=0)
    if st.button('Remove Selected Station'):
        if selected_loc_row >= st.session_state['stations_df'].height:
            st.error(f"Selected row {selected_loc_row} out of range.")

        # Remove selected location by adding a new index column
        st.session_state['stations_df'] = st.session_state['stations_df'].with_row_index().filter(
            ~pl.col("index").is_in([selected_loc_row]))

        # Drop the column so you can keep deleting rows
        st.session_state['stations_df'].drop_in_place("index")

        # Force a refresh of the selected locations dataframe - for some reason this doesn't happen automatically
        selected_locs.dataframe(st.session_state['stations_df'].to_pandas())
        selected_loc_count.markdown(f"**Number of Stations:** {st.session_state['stations_df'].height}")

    if st.button('Clear All Stations'):
        st.session_state['stations_df'] = pl.DataFrame({}, schema={
            'name': str,
            'provider': str,
            'longitude': float,
            'latitude': float,
            'altitude': float,
        })

        # Force a refresh of the selected locations dataframe - for some reason this doesn't happen automatically
        selected_locs.dataframe(st.session_state['stations_df'].to_pandas())
        selected_loc_count.markdown(f"**Number of Locations:** {st.session_state['stations_df'].height}")

    # Show Stations

    st_plot = st.empty()

    st_plot_cols = st.columns(4)
    with st_plot_cols[0]:
        plot_ele = st.number_input('Minimum Elevation (deg)', min_value=0.0, max_value=90.0, value=10.0, step=0.1,
                                   format='%.3f')
    with st_plot_cols[1]:
        plot_alt = st.number_input('Plot Altitude (km)', min_value=200.0, value=500.0, format='%.3f')
    with st_plot_cols[2]:
        plot_opacity = st.slider('Plot Opacity', min_value=0.0, max_value=1.0, value=0.5, step=0.01)

    plot_stations = [(row['longitude'], row['latitude'], row['provider']) for row in
                     st.session_state['stations_df'].iter_rows(named=True)]
    gs_fig, gs_ax = plots.plot_stations(plot_stations, elevation_min=plot_ele, alt=plot_alt * 1e3, opacity=plot_opacity)

    st_plot.pyplot(gs_fig)

    with st_plot_cols[3]:
        img = io.BytesIO()
        gs_fig.savefig(img, format='png')

        st.download_button(
            label="Download image",
            data=img,
            file_name='groundstations.png',
            mime="image/png"
        )


def satellite_selector():
    # Get current (or update) TLE data
    satcat_df = get_satcat_df()

    # Render Widget
    st.markdown('## Satellte Selection')

    if 'satellites_df' not in st.session_state:
        st.session_state['satellites_df'] = pl.DataFrame({}, schema={
            'object_name': str,
            'satcat_id': str,
            'epoch': datetime.datetime,
            'altitude': float,
            'semi_major_axis': float,
            'eccentricity': float,
            'inclination': float,
            'right_ascension': float,
            'arg_of_perigee': float,
            'mean_anomaly': float,
            'tle_line0': str,
            'tle_line1': str,
            'tle_line2': str
        })

    # Add satellites by elements

    st.markdown('### Add Satellte by Elements')

    sat_ele_cols = st.columns(2)

    object_name = sat_ele_cols[0].text_input('Object Name')
    satcat_id = sat_ele_cols[1].text_input('SATCAT ID')

    sat_date = sat_ele_cols[0].date_input('Ephemeris Epoch Day')
    sat_time = sat_ele_cols[1].time_input('Ephemeris Epoch Time (UTC)')

    # Add input fields for the TLE elements

    altitude = sat_ele_cols[0].number_input('Altitude (km)', min_value=200.0, value=500.0, format='%.3f')
    semi_major_axis = bh.R_EARTH + altitude * 1e3
    eccentricity = sat_ele_cols[1].number_input('Eccentricity', min_value=0.0, max_value=1.0, format='%.3f')

    sat_ele_cols[1].text('')  # Fake linebreak for formatting
    sat_sso = sat_ele_cols[1].checkbox('Sun-Synchronous Orbit', value=False, key="sun_sync_orbit")
    inclination = sat_ele_cols[0].number_input('Inclination (deg)', min_value=0.0, max_value=180.0,
                                               value=bh.sun_sync_inclination(semi_major_axis, eccentricity,
                                                                             use_degrees=True) if 'sun_sync_orbit' in st.session_state and st.session_state.sun_sync_orbit else 0.0,
                                               disabled=st.session_state.sun_sync_orbit if 'sun_sync_orbit' in st.session_state else False,
                                               format='%.3f')
    right_ascension = sat_ele_cols[0].number_input('Right Ascension (deg)', min_value=0.0, max_value=360.0,
                                                   format='%.3f')
    arg_of_perigee = sat_ele_cols[1].number_input('Argument of Perigee (deg)', min_value=0.0, max_value=360.0,
                                                  format='%.3f')
    mean_anomaly = sat_ele_cols[0].number_input('Mean Anomaly (deg)', min_value=0.0, max_value=360.0, format='%.3f')

    if st.button('Add Satellite', key='add_satellite_by_elements'):
        if satcat_id in st.session_state['satellites_df']['satcat_id']:
            st.error(f"Satellite with SATCAT ID {satcat_id} already selected.")

        elif object_name == '':
            st.error('Please provide a name for the satellite')
        elif satcat_id == '':
            st.error('Please provide a SATCAT ID for the satellite')
        elif len(satcat_id) != 5:
            st.error('SATCAT ID must be 5 digits long')

        else:
            tle_line1, tle_line2 = bh.tle_string_from_elements(
                bh.Epoch(sat_date.year, sat_date.month, sat_date.day, sat_time.hour, sat_time.minute, sat_time.second,
                         tsys='UTC'),
                [
                    bh.mean_motion(semi_major_axis, use_degrees=True) * 86400 / 360,
                    # Convert sma into mean motion rev/day
                    eccentricity, inclination, right_ascension, arg_of_perigee, mean_anomaly, 0.0, 0.0, 0.0],
                norad_id=int(satcat_id),
            )

            new_sat = pl.DataFrame({
                'object_name': object_name,
                'satcat_id': satcat_id,
                'epoch': datetime.datetime.now(),
                'altitude': (semi_major_axis - bh.R_EARTH)/1e3,
                'semi_major_axis': semi_major_axis,
                'eccentricity': eccentricity,
                'inclination': inclination,
                'right_ascension': right_ascension,
                'arg_of_perigee': arg_of_perigee,
                'mean_anomaly': mean_anomaly,
                'tle_line0': object_name,
                'tle_line1': tle_line1,
                'tle_line2': tle_line2
            })

            st.session_state['satellites_df'] = pl.concat([st.session_state['satellites_df'], new_sat]).unique()

    st.markdown('### Add Satellites by Constellation')
    constellations = st.multiselect('**Select Constellations:**', CONSTELLATIONS)

    if st.button('Add Constellations'):
        # Filter constellation data by name and add to existing data
        con_sats = satcat_df.filter(pl.col('object_name').str.contains_any(constellations))
        logger.info(f'Found {con_sats.height} satellites in constellations {constellations}')
        st.session_state['satellites_df'] = pl.concat([st.session_state['satellites_df'], con_sats]).unique()

    st.markdown('### Add Satellite by NORAD ID')

    # Get the min and max SATCAT ID numbers from the full TLE datafarme
    min_satcat_id = satcat_df['satcat_id'].min()
    max_satcat_id = satcat_df['satcat_id'].max()

    # SATCAT ID number input
    satcat_id = st.text_input(f'**SATCAT ID - Min: {min_satcat_id}, Max: {max_satcat_id}**')

    if satcat_id != None:
        pass
        satcat_df = satcat_df.filter(pl.col('satcat_id') == satcat_id)

        if satcat_df.height > 0:
            record = satcat_df.row(0, named=True)

            satcat_col1, satcat_col2 = st.columns(2)
            with satcat_col1:
                st.markdown(f"**Object Name:** {record['object_name']}")
                st.markdown(f"**Semi-Major Axis:** {record['semi_major_axis'] / 1e3:.3f} km")
                st.markdown(f"**Eccentricity:** {record['eccentricity']:.3f}")
                st.markdown(f"**Right Ascension:** {record['right_ascension']:.3f} deg")
                st.markdown(f"**Mean Anomaly:** {record['mean_anomaly']:.3f} deg")
            with satcat_col2:
                st.markdown(f"**TLE Epoch:** {record['epoch']}")
                st.markdown(f"**Altitude:** {(record['semi_major_axis'] - bh.R_EARTH) / 1e3:.3f} km")
                st.markdown(f"**Inclination:** {record['inclination']:.3f} deg")
                st.markdown(f"**Argument of Perigee:** {record['arg_of_perigee']:.3f} deg")

    else:
        st.error(f"No satellite with SATCAT ID {satcat_id} found.")

    if st.button('Add Satellite', key='add_satellite_by_satcat_id'):
        st.session_state['satellites_df'] = pl.concat([st.session_state['satellites_df'], satcat_df]).unique()

    # Show all selected satellites
    st.markdown('### Selected Satellites')

    # Create the dataframe of selected satellites
    satellites_count = st.empty()
    satellites_count.markdown(
        f"**Number of Selected Satellites:** {st.session_state['satellites_df'].height}")
    st_satellites = st.empty()
    st_satellites.dataframe(st.session_state['satellites_df'].drop(['tle_line0', 'tle_line1', 'tle_line2']).to_pandas())

    selected_sat_row = st.number_input('Selected satellite index', min_value=0)
    if st.button('Remove Selected Satellite'):
        if selected_sat_row >= st.session_state['satellites_df'].height:
            st.error(f"Selected satellite row {selected_sat_row} out of range.")

        # Remove selected satellite by adding a new index column
        st.session_state['satellites_df'] = st.session_state['satellites_df'].with_row_index().filter(
            ~pl.col("index").is_in([selected_sat_row]))

        # Drop the column so you can keep deleting rows
        st.session_state['satellites_df'].drop_in_place("index")

        # Force a refresh of the selected satellites dataframe - for some reason this doesn't happen automatically
        st_satellites.dataframe(st.session_state['satellites_df'].to_pandas())
        satellites_count.markdown(
            f"**Number of Selected Satellites:** {st.session_state['satellites_df'].height}")

    if st.button('Clear All Selected Satellites'):
        st.session_state['satellites_df'] = pl.DataFrame({}, schema={
            'object_name': str,
            'satcat_id': str,
            'epoch': datetime.datetime,
            'altitude': float,
            'semi_major_axis': float,
            'eccentricity': float,
            'inclination': float,
            'right_ascension': float,
            'arg_of_perigee': float,
            'mean_anomaly': float,
            'tle_line0': str,
            'tle_line1': str,
            'tle_line2': str
        })

        # Force a refresh of the selected satellites dataframe - for some reason this doesn't happen automatically
        st_satellites.dataframe(
            st.session_state['satellites_df'].drop(['tle_line0', 'tle_line1', 'tle_line2']).to_pandas())
        satellites_count.markdown(
            f"**Number of Selected Satellites:** {st.session_state['satellites_df'].height}")


def provider_cost_selector(provider: str):
    st.session_state.provider_costs[provider] = {}

    st.markdown(f'**{provider.capitalize()}**')

    default_cost_cols = st.columns(5)
    st.session_state['default_setup_cost'] = default_cost_cols[0].number_input('Default First Time Use Cost ($)', min_value=0.0, value=50000.0, format='%.2f', key=f'{provider}_setup_cost')
    st.session_state['default_per_satellite_license_cost'] = default_cost_cols[1].number_input('Default Per Satellite License Cost ($)', min_value=0.0, value=5000.0, format='%.2f', key=f'{provider}_per_satellite_license_cost')
    st.session_state['default_monthly_cost'] = default_cost_cols[2].number_input('Default Monthly ($)',
                                                                                  min_value=0.0, value=0.0,
                                                                                  format='%.2f',
                                                                                  key=f'{provider}_monthly_cost')
    st.session_state['default_cost_per_pass'] = default_cost_cols[2].number_input('Default Cost per Pass ($)', min_value=0.0, value=0.0, format='%.2f', key=f'{provider}_cost_per_pass')
    st.session_state['default_cost_per_minute'] = default_cost_cols[3].number_input('Default Cost per Minute ($)', min_value=0.0, value=0.0, format='%.2f', key=f'{provider}_cost_per_minute')

    st.session_state.provider_costs[provider]['integration_cost'] = st.number_input(
        f'{provider.capitalize()} Integration Cost ($)', min_value=0.0, value=st.session_state.default_integration_cost, format='%.2f', key=f'{provider}_integration_cost')

    with st.expander(f'{provider.capitalize()} Ground Station Costs'):
        cols = st.columns(5)

        for station in st.session_state['stations_df'].filter(pl.col('provider') == provider)['name'].to_list():
            st.session_state.provider_costs[provider][station] = {}

            st.session_state.provider_costs[provider][station]['setup_cost'] = cols[0].number_input(
                f'{station.capitalize()} Setup Cost ($)', min_value=0.0, value=st.session_state.default_setup_cost, format='%.2f', key=f'{provider}_{station}_setup_cost')
            st.session_state.provider_costs[provider][station]['per_satellite_license_cost'] = cols[1].number_input(
                f'{station.capitalize()} Per Satellite License Cost ($)', min_value=0.0, value=st.session_state.default_per_satellite_license_cost, format='%.2f', key=f'{provider}_{station}_per_satellite_license_cost')
            st.session_state.provider_costs[provider][station]['monthly_cost'] = cols[1].number_input(
                f'{station.capitalize()} Per Satellite License Cost ($)', min_value=0.0,
                value=st.session_state.default_monthly_cost, format='%.2f',
                key=f'{provider}_{station}_montly_cost')
            st.session_state.provider_costs[provider][station]['cost_per_pass'] = cols[3].number_input(
                f'{station.capitalize()} Cost per Pass ($)', min_value=0.0, value=st.session_state.default_cost_per_pass, format='%.2f', key=f'{provider}_{station}_cost_per_pass')
            st.session_state.provider_costs[provider][station]['cost_per_minute'] = cols[4].number_input(
                f'{station.capitalize()} Cost per Minute ($)', min_value=0.0, value=st.session_state.default_cost_per_minute, format='%.2f', key=f'{provider}_{station}_cost_per_minute')

def cost_model_selector():
    """
    Create widget to allow the user to define the cost model for the ground station optimization problem.
    """

    st.markdown('### Cost Model')
    st.markdown("""
    This section allows the user to define the costs associated with the use of different ground stations and providers.
    These costs are the primary drivers of the selection of ground stations and providers. There are multiple potential
    costs associated with the use of a ground station. These include:
      - **Integration Cost**: The cost for the operator to integrate the ground station into their provider. This is typically a one-time cost. It can conver both engineering time to integrate the station into the provider, as well as any hardware or software costs.
      - **Setup Cost**: The cost to setup a ground station for first use. This can include costs for setting up the station for use, such as provisioning operator-specific hardware at the station.
      - **Per Satellite License Cost**: The the one-time cost of any regulatory, licensing, or legal fees associated with using the station for a specific satellite.
      - **Monthly Cost**: The monthly fix cost of using the station. This cost is charged regardless of the number of passes or the duration of the passes. It is typically driven by monthly backhaul (internet) costs, power costs, or other fixed costs.
      - **Cost per Pass**: The cost of using the station for a single pass of a satellite. This is charged each time the station is used to communicate with a satellite, it is independent of the duration of the pass.
      - **Cost per Minute**: The cost of using the station for a single minute of communication with a satellite. This is charged based on the duration of the pass.
      
    Note a provider will typically charge either a cost per pass or a cost per minute, but not both.
    """)

    st.markdown('#### Cost Definition')

    st.session_state['default_integration_cost'] = st.number_input('Default Integration Cost ($)', min_value=0.0, value=100000.0, format='%.2f')


    st.session_state['provider_costs'] = {}

    for provider in sorted(st.session_state['stations_df']['provider'].unique().to_list()):
        provider_cost_selector(provider)

def create_satellite_datarate_selector():

    st.markdown('This section allows the user to define the data rates for the satellites in the optimization problem.')

    datarate_unit = st.selectbox('Data Rate Unit', ['bps', 'kbps', 'Mbps', 'Gbps'], index=3)
    default_datarate = st.number_input(f'Default Data Rate {datarate_unit}', min_value=0.0, value=1.2, format='%.2f')

    cols = st.columns(5)

    st.session_state['satellite_datarates'] = {}

    for idx, sat in enumerate(st.session_state['satellites_df'].iter_rows(named=True)):
        st.session_state['satellite_datarates'][sat['satcat_id']] = cols[idx % 5].number_input(
            f'{sat["object_name"]} Data Rate ({datarate_unit})', min_value=0.0, value=default_datarate, format='%.3f')

def create_groundstation_datarate_selector(provider: str, datarate_unit: str):

    st.markdown('This section allows the user to define the data rates for the ground stations in the optimization problem.')

    st.markdown(f'**{provider.capitalize()}**')

    default_datarate = st.number_input(f'{provider.capitalize()} Default Data Rate ({datarate_unit})', min_value=0.0, value=2.0, format='%.2f', key=f'{provider}_default_datarate')

    st.session_state['groundstation_datarates'][provider] = {}

    with st.expander(f'{provider.capitalize()} Ground Station Data Rates'):
        cols = st.columns(5)

        for idx, station in enumerate(st.session_state['stations_df'].filter(pl.col('provider') == provider).iter_rows(named=True)):
            st.session_state['groundstation_datarates'][provider][station['name']] = cols[idx % 5].number_input(
                f'{station["name"]} Data Rate ({datarate_unit})', min_value=0.0, value=default_datarate, format='%.3f', key=f'{provider}_{station["name"]}_datarate')


def downlink_model_selector():
    """
    Create widget to allow the user to define the downlink model for the ground station optimization problem.

    This model defines the downlink capabilities of the ground stations and the satellites.
    """

    st.markdown('### Data Model')
    st.markdown("""
    This section allows the user to define the data downlink model for the ground station optimization problem.
    The downlink model defines the capabilities of the ground stations and the satellites to communicate with each other.
    This model determines the effective amount of data that can be downlinked from the satellite to the ground station
    over a given contact. This section allows the user to define the datarate for each ground station and satellite.
    The datarate for a given contact is the minimum of the datarates of the satellite and the ground station.
    """)

    st.markdown('#### Satellite Data Rates')

    create_satellite_datarate_selector()

    st.markdown('#### Ground Station Data Rates')

    st.session_state['groundstation_datarates'] = {}

    datarate_unit = st.selectbox('Data Rate Unit', ['bps', 'kbps', 'Mbps', 'Gbps'], index=3, key='groundstation_datarate_unit')

    for provider in sorted(st.session_state['stations_df']['provider'].unique().to_list()):
        create_groundstation_datarate_selector(provider, datarate_unit)


def optimization_window_selector():
    """
    Allows the user to select the optimization window for the ground station optimization problem.
    """

    st.markdown('### Optimization Window Selection')

    st.markdown("""
    Here we can define the _optimization window_ and the _simulation window_ for the ground station optimization problem.
    The _optimization window_ is the period over which the problem is solved. This is the horizon over which 
    the problem of location and provider selection is considered. In most cases this should match the expected mission
    duration. 
    
    The _simulation window_ is the period over which the simulation is run. This is the period over which the optimizer
    calculates potential ground contacts and determines the best ground station to use. This window should be less than
    or equal to the _optimization window_. Normally, due to orbit progation uncertainties (primarily driven by 
    the solar cycle and atmospheric drag), it is not possible to accurately predict the exact satellite contact times
    over the entire life of the mission. Therefore, we use a shorter simulation window to simulate contacts for a shorter
    period (typically 7 days), and use that number as an approximation of the expected number of contacts
    over the mission lifetime for different ground station locations and providers.
    """)


    # Optimization Window
    st.markdown('#### Optimization Window')
    opt_cols = st.columns(2)
    with opt_cols[0]:
        opt_start = st.date_input('Optimization Window Start Date', value=datetime.datetime.now())
    with opt_cols[1]:
        opt_end = st.date_input('Optimization Window End Date', value=datetime.datetime.now() + datetime.timedelta(days=365))

    # Simulation Window
    st.markdown('#### Simulation Window')
    sim_cols = st.columns(2)
    with sim_cols[0]:
        sim_start = st.date_input('Simulation Window Start Date')
    with sim_cols[1]:
        sim_duration = st.number_input('Simulation Window Duration (days)', min_value=1, value=7)

    if sim_duration > (opt_end - opt_start).days:
        st.error('Simulation window duration must be less than or equal to the optimization window duration.')

    # Create and store an OptimizationWindow object
    opt_window = OptimizationWindow(
        opt_start=datetime.datetime.fromisoformat(opt_start.isoformat()),
        opt_end=datetime.datetime.fromisoformat(opt_end.isoformat()),
        sim_start=datetime.datetime.fromisoformat(sim_start.isoformat()),
        sim_end=datetime.datetime.fromisoformat((sim_start + datetime.timedelta(days=sim_duration)).isoformat())
    )

    st.session_state['opt_window'] = opt_window



def opt_problem_creator_widget():
    optimization_window_selector()

    st.markdown('### Optimization Problem Creation')

    st.markdown("""
    This section allows the user to define the optimization
    """)

    opt_type = st.selectbox('Optimization Type', ['MILP'], index=0)

    if st.button('Create Optimization Problem'):
        # Create the MILP optimizer
        st.session_state['gsopt'] = MilpOptimizer(opt_window=st.session_state['opt_window'])

        # Convert the selected satellites to Satellite objects and add to problem
        satellites = satellites_from_dataframe(st.session_state['satellites_df'])

        for sat in satellites:
            # Set datarate for satellite from inputs
            sat.datarate = st.session_state['satellite_datarates'][sat.satcat_id]

            # Add the satellite to the optimizer
            st.session_state['gsopt'].add_satellite(sat)

        # Convert the selected Ground Stations to providers and stations

        # Add provider stations to the optimizer
        for provider in st.session_state['stations_df']['provider'].unique().to_list():
            provider_stations = st.session_state['stations_df'].filter(pl.col('provider') == provider)
            stations = ground_stations_from_dataframe(provider_stations)

            # Create a provider for the provider
            provider = GroundStationProvider(stations)

            # Set the integration cost for the provider
            provider.integration_cost = st.session_state.provider_costs[provider]['integration_cost']

            # Set cost and datarate for each station
            for station in stations:
                station.datarate = st.session_state['groundstation_datarates'][provider][station.name]
                station.setup_cost = st.session_state.provider_costs[provider][station.name]['setup_cost']
                station.per_satellite_license_cost = st.session_state.provider_costs[provider][station.name]['per_satellite_license_cost']
                station.cost_per_pass = st.session_state.provider_costs[provider][station.name]['monthly_cost']
                station.cost_per_pass = st.session_state.provider_costs[provider][station.name]['cost_per_pass']
                station.cost_per_minute = st.session_state.provider_costs[provider][station.name]['cost_per_minute']

            # Add the provider to the optimizer
            st.session_state.gsopt.add_provider(provider)

        st.markdown(f"""
        Created optimization problem with:
        - Optimization Window: {st.session_state.gsopt.opt_window.opt_start} to {st.session_state.gsopt.opt_window.opt_end}
        - Simulation Window: {st.session_state.gsopt.opt_window.sim_start} to {st.session_state.gsopt.opt_window.sim_end}
        - {len(st.session_state.gsopt.satellites)} satellites
        - {len(st.session_state.gsopt.providers)} ground station providers
        - {len(st.session_state.gsopt.stations)} ground stations
        """)


    # Compute contact windows
    elevation_min = st.number_input('Minimum Elevation (deg)', min_value=0.0, max_value=90.0, value=10.0, step=0.1,)

    if st.button('Compute Contact Windows'):
        if 'gsopt' not in st.session_state:
            st.error('Please create the optimization problem before computing contacts.')
        else:
            # st.session_state['gsopt'].set_access_constraints(elevation_min)
            st.session_state.gsopt.compute_contacts()

            # st.markdown(f'Number of Contacts: {len(st.session_state.gsopt.contacts)}')
            st.success(f"Found {len(st.session_state.gsopt.contacts)} contacts. Contact computation took {utils.get_time_string(st.session_state.gsopt.contact_compute_time)}.")

    # Define Constraints and Objective

    # Solve Optimization problem
    if st.button('Solve Optimization Problem'):
        if 'gsopt' not in st.session_state:
            st.error('Please create the optimization problem before solving.')
        else:
            st.session_state.gsopt.solve()

            st.success(f'Optimization problem solved in {st.session_state.gsopt.solve_time:.2f} seconds')


"""
Module containing different objective functions for MILP optimization
"""

from abc import abstractmethod, ABCMeta
from itertools import groupby

import pyomo.kernel as pk

from gsopt.milp_core import ProviderNode, StationNode, ContactNode
from gsopt.models import OptimizationWindow
from gsopt.utils import time_milp_generation


class GSOptObjective(metaclass=ABCMeta):
    """
    Abstract class for the objective function of the MILP optimization.

    Enforces the implementation of the _generate_objective method.
    """

    def __init__(self, **kwargs):
        self.kwargs = kwargs

        self.obj = pk.objective()

        self.obj.expr = 0

    @abstractmethod
    def _generate_objective(self):
        pass

    def dict(self):
        return {
            'type': self.__class__.__name__,
            'args': self.kwargs
        }


class MinCostObjective(pk.block, GSOptObjective):
    """
    Objective function for the MILP optimization that minimizes the total cost (capital and operational) of the
    ground station provider over the optimization period.
    """

    def __init__(self, **kwargs):
        pk.block.__init__(self)
        GSOptObjective.__init__(self, **kwargs)

        # Set objective direction
        self.obj.sense = pk.minimize

    @time_milp_generation
    def _generate_objective(self, provider_nodes: dict[str, ProviderNode] | None = None,
                            station_nodes: dict[str, StationNode] | None = None,
                            contact_nodes: dict[str, ContactNode] | None = None,
                            station_satellite_nodes: dict[(str, str), pk.variable] | None = None,
                            opt_window: OptimizationWindow | None = None, **kwargs):
        """
        Generate the objective function.
        """

        # Add provider costs
        for pn_id, pn in provider_nodes.items():
            self.obj.expr += pn.model.integration_cost * provider_nodes[pn_id].var

        # Add station costs
        for sn_id, sn in station_nodes.items():
            self.obj.expr += sn.model.setup_cost * station_nodes[sn_id].var

            # Add monthly station costs, normalized to the optimization period
            self.obj.expr += (12 * opt_window.T_opt) / (365.25 * 86400.0 * opt_window.T_sim) * sn.model.monthly_cost * station_nodes[sn_id].var

            # Add satellite licensing costs for the station
            for key in filter(lambda x: x[0] == sn_id, station_satellite_nodes.keys()):
                self.obj.expr += sn.model.per_satellite_license_cost * station_satellite_nodes[key]

        # Add contact costs
        for cn_id, cn in contact_nodes.items():
            self.obj.expr += opt_window.T_opt / opt_window.T_sim * (cn.model.t_duration * cn.model.cost_per_minute + cn.model.cost_per_pass) * contact_nodes[cn_id].var


class MaxDataDownlinkObjective(pk.block, GSOptObjective):
    """
    Objective function for the MILP optimization that maximizes the total data downlinked by the constellation over the
    optimization period.
    """

    def __init__(self, **kwargs):
        pk.block.__init__(self)
        GSOptObjective.__init__(self, **kwargs)

        # Set objective direction
        self.obj.sense = pk.maximize

    @time_milp_generation
    def _generate_objective(self, provider_nodes: dict[str, ProviderNode] | None = None,
                            station_nodes: dict[str, StationNode] | None = None,
                            contact_nodes: dict[str, ContactNode] | None = None,
                            opt_window: OptimizationWindow | None = None, **kwargs):
        """
        Generate the objective function.
        """

        for cn in contact_nodes.values():
            self.obj.expr += cn.var * cn.model.data_volume * opt_window.T_opt / opt_window.T_sim


class MinMaxContactGapObjective(pk.block, GSOptObjective):
    """
    Objective function for the MILP optimization that minimizes the maximum gap between contacts across all satellites
    in the constellation over the optimization period.
    """

    def __init__(self, **kwargs):
        pk.block.__init__(self)
        GSOptObjective.__init__(self, **kwargs)

        # Set objective direction
        self.obj.sense = pk.minimize

        # Initialize constraints required to implement the objective
        self.constraints = pk.constraint_list()

    @time_milp_generation
    def _generate_objective(self, provider_nodes: dict[str, ProviderNode] | None = None,
                            station_nodes: dict[str, StationNode] | None = None,
                            contact_nodes: dict[str, ContactNode] | None = None,
                            opt_window: OptimizationWindow | None = None, **kwargs):
        """
        Generate the objective function.
        """

        # Group contacts by satellite
        contact_nodes_by_satellite = sorted(contact_nodes.values(), key=lambda cn: cn.satellite.id)

        self.variable_dict = pk.variable_dict()

        # Create auxiliary variable for the max gap across all satellites and contacts
        self.variable_dict['max_gap'] = pk.variable(value=0.0, domain=pk.NonNegativeReals)

        # Set objective to minimize the maximum gap
        self.obj.expr = self.variable_dict['max_gap']

        for sat_id, sat_contacts in groupby(contact_nodes_by_satellite, lambda cn: cn.satellite.id):
            # Sort contacts by start time
            sat_contacts = list(sorted(sat_contacts, key=lambda cn: cn.model.t_start))

            # For each contact, create an auxiliary variable for the next scheduled task
            for i, cn_i in enumerate(sat_contacts[0:len(sat_contacts) - 1]):

                # Working expression for the next scheduled contact
                expr = pk.expression(0)

                for j, cn_j in enumerate(filter(lambda cn: cn.model.t_start > cn_i.model.t_end, sat_contacts)):
                    # Auxiliary variable if contact j is the next scheduled after contact i
                    self.variable_dict[(sat_id, cn_i.model.id, cn_j.model.id)] = pk.variable(value=0, domain=pk.Binary)

                    expr += self.variable_dict[(sat_id, cn_i.model.id, cn_j.model.id)]

                    # Constraints to ensure that if the auxiliary variable is 1, then both x_i and x_j are 1
                    self.constraints.append(pk.constraint(
                        self.variable_dict[(sat_id, cn_i.model.id, cn_j.model.id)] <= contact_nodes[cn_i.id].var))
                    self.constraints.append(pk.constraint(
                        self.variable_dict[(sat_id, cn_i.model.id, cn_j.model.id)] <= contact_nodes[cn_j.id].var))

                    # Add constraint to ensure that the associated scheduled gap is less than the maximum
                    self.constraints.append(pk.constraint((cn_j.model.t_start - cn_i.model.t_end) * self.variable_dict[
                        (sat_id, cn_i.model.id, cn_j.model.id)] <= self.variable_dict['max_gap']))
                    # print(self.constraints[-1].expr)


                # Add constraint that only one of the auxiliary variables can be 1 if the contact node is scheduled
                self.constraints.append(pk.constraint(expr == contact_nodes[cn_i.id].var))
import math
import shapely
import cartopy.geodesic
import cartopy.crs as ccrs
import matplotlib.pyplot as plt

import brahe as bh


def select_color(owner):
    if owner.lower() == 'aws':
        return 'orange'
    elif owner.lower() == 'ksat':
        return 'red'
    elif owner.lower() == 'atlas':
        return 'purple'
    elif owner.lower() == 'viasat':
        return 'yellow'
    elif owner.lower() in ['leaf space', 'leaf']:
        return 'green'
    elif owner.lower() == 'azure':
        return 'blue'
    elif owner.lower() == 'ssc':
        return 'cyan'
    else:
        return 'grey'

def compute_look_angle_max(ele=0.0, alt=525e3):
    ele = ele * math.pi / 180.0

    rho = math.asin(bh.R_EARTH/(bh.R_EARTH + alt))

    eta = math.asin(math.cos(ele)*math.sin(rho))
    lam = math.pi/2.0 - eta - ele

    return lam

def plot_stations(stations: list[tuple[float, float, str]], elevation_min:float=10, alt:float=500e3, opacity=0.5, ax=None):
    lam = compute_look_angle_max(ele=elevation_min, alt=alt)

    fig = plt.figure(figsize=(10, 5))
    ax = plt.axes(projection=ccrs.PlateCarree())
    ax.set_global()
    ax.stock_img()

    # Hide the axes
    for spine in ax.spines.values():
        spine.set_visible(False)

    for station in stations:
        lon, lat = station[0], station[1]

        c = select_color(station[2])

        # Plot Groundstation Location
        ax.plot(lon, lat, color=c, marker='o', markersize=3, transform=ccrs.Geodetic())

        circle_points = cartopy.geodesic.Geodesic().circle(lon=lon, lat=lat, radius=lam * bh.R_EARTH, n_samples=100,
                                                           endpoint=False)
        geom = shapely.geometry.Polygon(circle_points)
        ax.add_geometries((geom,), crs=ccrs.Geodetic(), facecolor=c, alpha=opacity, edgecolor='none', linewidth=0)

    return fig, aximport pyomo.kernel as pk


class Node(pk.block):
    """
    Generic node class representing an element in the MILP model.

    Args:
        id (str): Unique identifier for the node.
        obj (gsopt.model): Object being represented by the node.

    Note:
        The field name "children" is inherited from the pk.block class so it is not used here.
    """

    def __init__(self, **kwargs):
        super().__init__()
        self.model = kwargs['obj']
        self.id = self.model.id

    def dict(self):
        d = {
            "id:": self.id,
            "type": type(self).__name__,
        }

        return d


class BinaryNode(Node):
    """
    Node class representing a binary decision variable. Inherits from the Node class.

    Attributes:
        var (pyomo.kernel.variable): Binary decision variable
    """

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.var = pk.variable(value=0, domain=pk.Binary)

    def dict(self):
        d = super().dict()

        # Add class specific attributes

        return d


class ProviderNode(BinaryNode):
    """
    Node class representing a provider. Inherits from the Node class.

    Attributes:
        var (pyomo.kernel.variable): binary decision variable
    """

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    def dict(self):
        d = super().dict()

        # Add class specific attributes

        return d


class StationNode(BinaryNode):
    """
    Node class representing a station. Inherits from the Node class.

    Attributes:
        var (pyomo.kernel.variable): binary decision variable
    """

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.provider = kwargs['provider']

    def dict(self):
        d = super().dict()

        # Add class specific attributes

        return d


class ContactNode(BinaryNode):
    """
    Node class representing a contact. Inherits from the Node class.

    Attributes:
        var (pyomo.kernel.variable): binary decision variable
    """

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.station = kwargs['station']
        self.provider = kwargs['provider']
        self.satellite = kwargs['satellite']

    @property
    def duration(self):
        return self.model.duration

    @property
    def t_start(self):
        return self.model.t_start

    @property
    def t_end(self):
        return self.model.t_end

    def dict(self):
        d = super().dict()

        # Add class specific attributes

        return d


class SatelliteNode(BinaryNode):
    """
    Node class representing a satellite. Inherits from the Node class.

    Attributes:
        var (pyomo.kernel.variable): binary decision variable
    """

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    def dict(self):
        d = super().dict()

        # Add class specific attributes

        return d"""
Module containing different objective functions for MILP optimization
"""

import copy
import logging

from abc import abstractmethod, ABCMeta
from itertools import combinations, groupby

import pyomo.kernel as pk

from gsopt.milp_core import ProviderNode, StationNode, ContactNode
from gsopt.models import OptimizationWindow
from gsopt.utils import time_milp_generation

logger = logging.getLogger(__name__)


class GSOptConstraint(metaclass=ABCMeta):
    """
    Abstract class for the constraint_list function of the MILP optimization.

    Enforces the implementation of the _generate_constraints method.
    """

    def __init__(self, **kwargs):

        self.kwargs = kwargs

        self.constraints = pk.constraint_list()

    @abstractmethod
    def _generate_constraints(self):
        pass

    def dict(self):
        return {
            'type': self.__class__.__name__,
            'args': self.kwargs
        }

class MinConstellationDataDownlinkConstraint(pk.block, GSOptConstraint):
    """
    Constraint function that enforces that the total data downlinked by the constellation is greater than or equal to
    the given threshold over a given period.

    Args:
        value (float): The minimum data downlinked by the constellation in bits over the period.
        period (float): The period over which the value is enforced in seconds.
        step (float): The interval at which the constraint is enforced in seconds.
    """

    def __init__(self, value: float = 0.0, period: float = 86400.0, step: float = 300, **kwargs):
        pk.block.__init__(self)
        GSOptConstraint.__init__(self, value=value, period=period, step=step)

        if period <= 0:
            raise ValueError("Period must be greater than zero.")

        if value <= 0:
            raise ValueError("Limit must be greater than zero.")

        if step <= 0:
            raise ValueError("Step must be greater than zero.")

        self.value = value
        self.period = period
        self.step = step

    @time_milp_generation
    def _generate_constraints(self,
                             contact_nodes: dict[str, ContactNode] | None = None,
                             opt_window: OptimizationWindow | None = None, **kwargs):
        """
        Generate the constraint_list function.
        """

        ts = copy.deepcopy(opt_window.sim_start)  # Working variable for the start of the current period
        te = copy.deepcopy(ts + self.period)  # Working variable for the end of the current period

        t_max = opt_window.sim_end  # The end of the constraint period

        # Get contacts in the current period, sorted by start time
        contacts = sorted(list(contact_nodes.values()), key=lambda cn: cn.model.t_start)

        while te <= t_max:
            # Get contacts in the current period
            contacts_in_period = filter(lambda cn: cn.model.t_end >= ts and cn.model.t_start <= te, contacts)

            # Add the constraint
            self.constraints.append(pk.constraint(sum(cn.model.datarate * cn.model.t_duration * contact_nodes[cn.id].var for cn in contacts_in_period) >= self.value))

            # Move to the next period
            ts += self.step
            te += self.step


class MinSatelliteDataDownlinkConstraint(pk.block, GSOptConstraint):
    """
    Constraint function that enforces that the total data downlinked by the satellite is greater than or equal to
    a given threshold over a given period.

    If a satellite key is provided, the constraint is applied to that satellite only. Otherwise, the constraint is
    applied to each satellite in the constellation.

    Args:
        value (float): The minimum data downlinked by the satellite in bits over the period.
        period (float): The period over which the value is enforced in seconds.
        step (float): The interval at which the constraint is enforced in seconds.
        satellite_key (str): The unique key (id or name) of the satellite to which the constraint applies.
    """

    def __init__(self, value: float = 0.0, period: float = 86400.0, step: float = 300,
                 satellite_key: str | int | None = None, **kwargs):
        pk.block.__init__(self)
        GSOptConstraint.__init__(self, value=value, period=period, step=step, satellite_key=satellite_key)

        if period <= 0:
            raise ValueError("Period must be greater than zero.")

        if value <= 0:
            raise ValueError("Limit must be greater than zero.")

        if step <= 0:
            raise ValueError("Step must be greater than zero.")

        self.value = value
        self.period = period
        self.step = step


        self.satellite_key = satellite_key
        self._matched_id = None

    @time_milp_generation
    def _generate_constraints(self,
                             contact_nodes: dict[str, ContactNode] | None = None,
                             opt_window: OptimizationWindow | None = None, **kwargs):
        """
        Generate the constraint_list function.
        """

        t_max = opt_window.sim_end  # The end of the constraint period

        # If a satellite key was provided, attempt to match it
        if self.satellite_key is not None:
            satellite_contacts = list(filter(lambda cn:
                                        self.satellite_key in [cn.satellite.id, cn.satellite.name, cn.satellite.satcat_id], contact_nodes.values()))

            if len(satellite_contacts) == 0:
                raise RuntimeError(f"Could not find a satellite with key \"{self.satellite_key}\".")

            # Sort the contacts by start time
            satellite_contacts = sorted(satellite_contacts, key=lambda cn: cn.model.t_start)

            # Apply the constraint to the satellite
            ts = copy.deepcopy(opt_window.sim_start)  # Working variable for the start of the current period
            te = copy.deepcopy(ts + self.period)  # Working variable for the end of the current period

            while te <= t_max:
                # Get contacts in the current period
                contacts_in_period = filter(lambda cn: cn.model.t_end >= ts and cn.model.t_start <= te, satellite_contacts)

                # Add the constraint
                self.constraints.append(pk.constraint(sum(cn.model.datarate * cn.model.t_duration * contact_nodes[cn.id].var for cn in contacts_in_period) >= self.value))

                # Move to the next period
                ts += self.step
                te += self.step

        else:
            # Get unique satellite ids:
            satellite_ids = set([cn.satellite.id for cn in contact_nodes.values()])

            for satellite_id in satellite_ids:
                satellite_contacts = filter(lambda cn: cn.satellite.id == satellite_id, contact_nodes.values())

                # Sort the contacts by start time
                satellite_contacts = sorted(satellite_contacts, key=lambda cn: cn.model.t_start)

                ts = copy.deepcopy(opt_window.sim_start)  # Working variable for the start of the current period
                te = copy.deepcopy(ts + self.period)  # Working variable for the end of the current period

                while te <= t_max:
                    # Get contacts in the current period
                    contacts_in_period = filter(lambda cn: cn.model.t_end >= ts and cn.model.t_start <= te, satellite_contacts)

                    # Add the constraint
                    self.constraints.append(pk.constraint(sum(cn.model.datarate * cn.model.t_duration * contact_nodes[cn.id].var for cn in contacts_in_period) >= self.value))

                    # Move to the next period
                    ts += self.step
                    te += self.step


class MaxOperationalCostConstraint(pk.block, GSOptConstraint):
    """
    Constraint function that enforces that the operational cost of the constellation is less than or equal to a given
    amount over a desired time period.

    Operational costs are monthly station use costs and contact costs.
    """

    def __init__(self, value: float | None = None, **kwargs):
        pk.block.__init__(self)
        GSOptConstraint.__init__(self, value=value)

        if not value:
            raise ValueError("Value must be provided.")

        self.value = value

    @time_milp_generation
    def _generate_constraints(self,
                             station_nodes: dict[str, StationNode] | None = None,
                             contact_nodes: dict[str, ContactNode] | None = None,
                             opt_window: OptimizationWindow | None = None, **kwargs):
        """
        Generate the constraint_list function.
        """

        # Define an expression for the operational cost
        expr = pk.expression(0)

        # Add station use costs
        for sn in station_nodes.values():
            expr += sn.model.monthly_cost * sn.var

        # Add contact costs
        for cn in contact_nodes.values():
            # The weight here converts the pass costs over the simulation window to an approximate monthly cost
            expr +=(86400.0 * 365.25) / (12 * opt_window.sim_duration) * (cn.model.cost_per_minute * cn.model.t_duration + cn.model.cost_per_pass) * contact_nodes[cn.id].var

        # Add constraint cost
        self.constraints.append(pk.constraint(expr <= self.value))


class MaxAntennaUsageConstraint(pk.block, GSOptConstraint):
    """
    Constraint function that enforces that the number of simultaneous contacts a station can have is less than or equal
    to the number of antennas at the station.
    """

    def __init__(self, **kwargs):
        pk.block.__init__(self)
        GSOptConstraint.__init__(self)

    @time_milp_generation
    def _generate_constraints(self, provider_nodes: dict[str, ProviderNode] | None = None,
                             station_nodes: dict[str, StationNode] | None = None,
                             contact_nodes: dict[str, ContactNode] | None = None,
                             opt_window: OptimizationWindow | None = None, **kwargs):
        """
        Generate the constraint_list function.
        """

        # Group nodes by station
        contact_nodes_by_station = sorted(contact_nodes.values(), key=lambda cn: cn.station.id)

        for station_id, station_contacts in groupby(contact_nodes_by_station, lambda cn: cn.station.id):

            # Get number of antennas for station
            antennas = station_nodes[station_id].model.antennas

            # Sort contacts by start time
            station_contacts = sorted(station_contacts, key=lambda cn: cn.model.t_start)

            # This is an inefficient way to enforce the constraint, but it is simple
            # It works by getting all potential combinations of contacts for the station that could result in the
            # constraint being exceeded, then checks that this combination has a time where all contacts do indeed
            # overlap, then it enforces that only up to the antenna limit is taken.

            # The +1 is used because we only want to check combinations which might exceed the constraint
            contact_combos = list(combinations(station_contacts, antennas + 1))

            for contacts in contact_combos:
                if all(x.model.t_start <= y.model.t_end and y.model.t_start <= x.model.t_end for x, y in combinations(contacts, 2)):
                    self.constraints.append(pk.constraint(sum(contact_nodes[cn.id].var for cn in contacts) <= antennas))


class SatelliteContactExclusionConstraint(pk.block, GSOptConstraint):
    """
    Enforces that a satellite cannot have contacts with two different stations at the same time.
    """

    def __init__(self, **kwargs):
        pk.block.__init__(self)
        GSOptConstraint.__init__(self)

    @time_milp_generation
    def _generate_constraints(self,
                             contact_nodes: dict[str, ContactNode] | None = None,
                             opt_window: OptimizationWindow | None = None, **kwargs):
        """
        Generate the constraint_list function.
        """

        # Filter contacts by satellite
        contact_nodes_by_satellite = sorted(contact_nodes.values(), key=lambda cn: str(cn.satellite.id))

        for sat_id, sat_contacts in groupby(contact_nodes_by_satellite, lambda cn: cn.satellite.id):

            # Sort contacts by start time
            sat_contacts = sorted(sat_contacts, key=lambda cn: cn.model.t_start)

            # Test all combinations of two contacts to see if they overlap
            # This could be done more efficiently, but the number of contacts is generally expected to be
            # small enough that this is not a problem
            for x, y in combinations(sat_contacts, 2):
                if x.model.t_start <= y.model.t_end and y.model.t_start <= x.model.t_end:
                    self.constraints.append(pk.constraint(x.var + y.var <= 1))

class StationContactExclusionConstraint(pk.block, GSOptConstraint):
    """
    Enforces that a station cannot have contacts with two different satellites at the same time.
    """

    def __init__(self, **kwargs):
        pk.block.__init__(self)
        GSOptConstraint.__init__(self)

    @time_milp_generation
    def _generate_constraints(self,
                             contact_nodes: dict[str, ContactNode] | None = None,
                             opt_window: OptimizationWindow | None = None, **kwargs):
        """
        Generate the constraint_list function.
        """

        # Filter contacts by station
        contact_nodes_by_station = sorted(contact_nodes.values(), key=lambda cn: str(cn.station.id))

        for sat_id, sta_contacts in groupby(contact_nodes_by_station, lambda cn: cn.station.id):

            # Sort contacts by start time
            sta_contacts = sorted(sta_contacts, key=lambda cn: cn.model.t_start)

            # Test all combinations of two contacts to see if they overlap
            # This could be done more efficiently, but the number of contacts is generally expected to be
            # small enough that this is not a problem
            for x, y in combinations(sta_contacts, 2):
                if x.model.t_start <= y.model.t_end and y.model.t_start <= x.model.t_end:
                    self.constraints.append(pk.constraint(x.var + y.var <= 1))


class MaxContactGapConstraint(pk.block, GSOptConstraint):
    """
    Constraint that enforces that the time between two contacts for any satellite is less than or equal to a given
    time period.

    Args:
        value (float): The maximum time between contacts in seconds.
    """

    def __init__(self, value: float | None = None, **kwargs):
        pk.block.__init__(self)
        GSOptConstraint.__init__(self, value=value)

        if not value:
            raise ValueError("Value must be provided.")

        self.value = value

    @time_milp_generation
    def _generate_constraints(self, provider_nodes: dict[str, ProviderNode] | None = None,
                             station_nodes: dict[str, StationNode] | None = None,
                             contact_nodes: dict[str, ContactNode] | None = None,
                             opt_window: OptimizationWindow | None = None, **kwargs):
        """
        Generate the constraint_list function.
        """

        # Group contacts by satellite
        contact_nodes_by_satellite = sorted(contact_nodes.values(), key=lambda cn: cn.satellite.id)

        self.variable_dict = pk.variable_dict()

        for sat_id, sat_contacts in groupby(contact_nodes_by_satellite, lambda cn: cn.satellite.id):
            # Sort contacts by start time
            sat_contacts = list(sorted(sat_contacts, key=lambda cn: cn.model.t_start))

            # For each contact, create an auxiliary variable for the next scheduled task
            for i, cn_i in enumerate(sat_contacts[0:len(sat_contacts) - 1]):

                # Working expression for the next scheduled contact
                expr = pk.expression(0)

                for j, cn_j in enumerate(filter(lambda cn: cn.model.t_start > cn_i.model.t_end, sat_contacts)):
                    # Auxiliary variable if contact j is the next scheduled after contact i
                    self.variable_dict[(sat_id, cn_i.model.id, cn_j.model.id)] = pk.variable(value=0, domain=pk.Binary)

                    expr += self.variable_dict[(sat_id, cn_i.model.id, cn_j.model.id)]

                    # Constraints to ensure that if the auxiliary variable is 1, then both x_i and x_j are 1
                    self.constraints.append(pk.constraint(self.variable_dict[(sat_id, cn_i.model.id, cn_j.model.id)] <= contact_nodes[cn_i.id].var))
                    self.constraints.append(pk.constraint(self.variable_dict[(sat_id, cn_i.model.id, cn_j.model.id)] <= contact_nodes[cn_j.id].var))

                    # Add constraint to ensure that the associated scheduled gap is less than the maximum
                    self.constraints.append(pk.constraint((cn_j.model.t_start - cn_i.model.t_end) * self.variable_dict[(sat_id, cn_i.model.id, cn_j.model.id)] <= self.value))

                # Add constraint that only one of the auxiliary variables can be 1 if the contact node is scheduled
                self.constraints.append(pk.constraint(expr == contact_nodes[cn_i.id].var))


class MaxProvidersConstraint(pk.block, GSOptConstraint):
    """
    Constraint that enforces the number of ground station providers that can be selected is less than or equal to
    the given number.
    """

    def __init__(self, num_providers: int = 1, **kwargs):
        pk.block.__init__(self)
        GSOptConstraint.__init__(self, num_providers=num_providers)

        self.num_providers = num_providers

    @time_milp_generation
    def _generate_constraints(self, provider_nodes: dict[str, ProviderNode] | None = None, **kwargs):
        """
        Generate the constraint_list function.
        """

        self.constraints.append(pk.constraint(sum(pn.var for pn in provider_nodes.values()) <= self.num_providers))

class MaxStationsConstraint(pk.block, GSOptConstraint):
    """
    Constraint that enforces the number of ground station locations that can be selected is less than or equal to
    the given number.
    """

    def __init__(self, num_stations: int = 1, **kwargs):
        pk.block.__init__(self)
        GSOptConstraint.__init__(self, num_providers=num_stations)

        self.num_stations = num_stations

    @time_milp_generation
    def _generate_constraints(self, station_nodes: dict[str, StationNode] | None = None, **kwargs):
        """
        Generate the constraint_list function.
        """

        self.constraints.append(pk.constraint(sum(pn.var for pn in station_nodes.values()) <= self.num_stations))


class MinContactDurationConstraint(pk.block, GSOptConstraint):
    """
    Constraint that enforces the minimum duration of a contact between a satellite and a ground station is greater than
    or equal to the given time period.
    """

    def __init__(self, min_duration: float = 300, **kwargs):
        pk.block.__init__(self)
        GSOptConstraint.__init__(self, min_duration=min_duration)

        if min_duration <= 0:
            raise ValueError("Minimum duration must be greater than zero.")

        self.min_duration = min_duration

    @time_milp_generation
    def _generate_constraints(self, contact_nodes: dict[str, ContactNode] | None = None, **kwargs):
        """
        Generate the constraint_list function.
        """

        for cn in contact_nodes.values():
            if cn.model.t_duration <= self.min_duration:
                # Force all contacts with duration less than the minimum to be zero
                self.constraints.append(pk.constraint(cn.var == 0))


class MaxContactsPerPeriodConstraint(pk.block, GSOptConstraint):
    """
    Constraint that enforces that the total number of contacts in any given period is less than or equal to the given
    limit. The usual period is a day.

    Args:
        value (int): The maximum number of contacts allowed in the period.
        period (float): The period over which the value is enforced in seconds.
        step (float): The interval at which the constraint is enforced in seconds.
    """

    def __init__(self, value: int = 16, period: float = 86400.0, step: float = 300, **kwargs):
        pk.block.__init__(self)
        GSOptConstraint.__init__(self, value=value, period=period, step=step)

        if period <= 0:
            raise ValueError("Period must be greater than zero.")

        if value <= 0:
            raise ValueError("Limit must be greater than zero.")

        if step <= 0:
            raise ValueError("Step must be greater than zero.")

        self.value = value
        self.period = period
        self.step = step

    @time_milp_generation
    def _generate_constraints(self, provider_nodes: dict[str, ProviderNode] | None = None,
                             station_nodes: dict[str, StationNode] | None = None,
                             contact_nodes: dict[str, ContactNode] | None = None,
                             opt_window: OptimizationWindow | None = None, **kwargs):
        """
        Generate the constraint_list function.
        """

        ts = copy.deepcopy(opt_window.sim_start)  # Working variable for the start of the current period
        te = copy.deepcopy(ts + self.period)      # Working variable for the end of the current period

        t_max = opt_window.sim_end  # The end of the constraint period

        # Get contacts in the current period, sorted by start time
        contacts = sorted(contact_nodes.values(), key=lambda cn: cn.model.t_start)

        while te <= t_max:
            # Get contacts in the current period
            contacts_in_period = filter(lambda cn: cn.model.t_end >= ts and cn.model.t_start <= te, contacts)

            # Add the constraint
            self.constraints.append(pk.constraint(sum(contact_nodes[cn.id].var for cn in contacts_in_period) <= self.value))

            # Move to the next period
            ts += self.step
            te += self.step


class RequireProviderConstraint(pk.block, GSOptConstraint):
    """
    Constraint to require a specific provider to be selected.
    """

    def __init__(self, key: str = None, **kwargs):
        pk.block.__init__(self)
        GSOptConstraint.__init__(self, key=key)

        if key is None:
            raise ValueError("A unique key (id or name) for the provider must be provided")

        self.key = key
        self._matched_id = None

    @time_milp_generation
    def _generate_constraints(self, provider_nodes: dict[str, ProviderNode] | None = None, **kwargs):
        """
        Generate the constraint_list function.
        """

        # Note: this mattaching has to be done in the _generate_constraints method not in the __init__ method
        # because the provider_nodes dictionary is not available at the time of object creation. It is
        # passed as an argument to the _generate_constraints method at the time of optimization.

        # Attempt to match the key to the provider id
        if self.key in provider_nodes.keys():
            self._matched_id = self.key

        # Otherwise attempt to match the key to the provider name
        for pn in provider_nodes.values():
            if pn.model.name.lower() == self.key.lower():
                self._matched_id = pn.model.id
                break

        if self._matched_id is None:
            raise RuntimeError(f"Could not find a provider with key \"{self.key}\"")

        self.constraints.append(pk.constraint(provider_nodes[self._matched_id].var == 1))


class RequireStationConstraint(pk.block, GSOptConstraint):
    """
    Constraint to require a specific station to be selected.
    """

    def __init__(self, id: str | None = None, name: str | None = None, provider: str | None = None, **kwargs):
        pk.block.__init__(self)
        GSOptConstraint.__init__(self, id=id, name=name, provider=provider)

        self.required_id = None
        self.required_name = None
        self.required_provider = None

        if id is None:
            if name is None or provider is None:
                raise ValueError("Either the station id or the station name and provider name must be provided.")

            self.required_provider = provider
            self.required_name = name

        if id is not None:
            if name is not None or provider is not None:
                raise ValueError("Providing the station id requires no other arguments.")

            self.required_id = id

        self._matched_id = None

    @time_milp_generation
    def _generate_constraints(self, station_nodes: dict[str, StationNode] | None = None, **kwargs):
        """
        Generate the constraint_list function.
        """

        # If and ID was provided, attempt to match it
        if self.required_id is not None:
            if self.required_id in station_nodes.keys():
                self.constraints.append(pk.constraint(station_nodes[self.required_id].var == 1))
                return
            else:
                raise RuntimeError(f"Could not find a station with id \"{self.required_id}\".")

        # Otherwise attempt to match the name and provider
        for sn in station_nodes.values():
            if sn.model.name.lower() == self.required_name.lower() and sn.model.provider.lower() == self.required_provider.lower():
                self.constraints.append(pk.constraint(station_nodes[sn.id].var == 1))
                return

        raise RuntimeError(f"Could not find a station with name \"{self.required_name}\" and provider \"{self.required_provider}\".")

class StationNumberConstraint(pk.block, GSOptConstraint):
    """
    Constraint to require a specific number of stations to be selected. The minimum, maximum, or both bounds
    must be provided. If a provider is provided then the constraint is applied to the stations of that provider.
    """

    def __init__(self, minimum: int | None = None, maximum: int | None = None, provider: str | None = None, **kwargs):
        pk.block.__init__(self)
        GSOptConstraint.__init__(self, minimum=minimum, maximum=maximum, provider=provider)

        self.minimum = minimum
        self.maximum = maximum
        self.provider = provider

        if minimum is None and maximum is None:
            raise ValueError("Either the minimum or maximum number of stations must be provided.")

    @time_milp_generation
    def _generate_constraints(self, station_nodes: dict[str, StationNode] | None = None, **kwargs):
        """
        Generate the constraint_list function.
        """

        if self.provider is not None:
            station_nodes = filter(lambda sn: sn.model.provider == self.provider, station_nodes.values())
        else:
            station_nodes = station_nodes.values()

        if self.minimum is not None:
            self.constraints.append(pk.constraint(sum(sn.var for sn in station_nodes) >= self.minimum))

        if self.maximum is not None:
            self.constraints.append(pk.constraint(sum(sn.var for sn in station_nodes) <= self.maximum))'''
General utilities and helper functions
'''

import os
import math
import pathlib
import time
import datetime
import warnings
import time
import logging
from functools import wraps

import polars as pl
import multiprocessing as mp

from typing import Dict, Any

import brahe as bh
import brahe.data_models as bdm
from brahe.access.access import find_location_accesses

import streamlit as st
from stqdm import stqdm as stqdm

from gsopt.models import Satellite, GroundStation, Contact

# Set up logging
# change asc time to
LOG_FORMAT_VERBOSE = '%(asctime)s.%(msecs)03d:%(levelname)8s [%(filename)20s:%(lineno)4d] %(message)s'
LOG_DATE_FORMAT = '%Y-%m-%dT%H:%M:%S'

logging.basicConfig(
    datefmt=LOG_DATE_FORMAT,
    format=LOG_FORMAT_VERBOSE,
    level=logging.INFO
)
logger = logging.getLogger(__name__)


APPLIED_FILTER_WARNINGS = False
def filter_warnings():
    global APPLIED_FILTER_WARNINGS

    if not APPLIED_FILTER_WARNINGS:
        warnings.filterwarnings("ignore", message="Approximating coordinate system")
        warnings.filterwarnings("ignore", message="streamlit run")
        warnings.filterwarnings("ignore", message="Session state does")
        warnings.filterwarnings("ignore", message="Warning: to view a Streamlit app")
        APPLIED_FILTER_WARNINGS = True

def get_last_modified_time(file_path):
    return os.path.getmtime(file_path)

def get_last_modified_time_as_datetime(file_path):
    return datetime.datetime.fromtimestamp(get_last_modified_time(file_path))

def compute_contacts(station: GroundStation, satellite: Satellite, t_start: bh.Epoch, t_end: bh.Epoch):
    # Convert Spacecraft and Station objects to Brahe objects
    sc = satellite.as_brahe_model()
    loc = station.as_brahe_model()

    contacts = find_location_accesses(sc, loc, t_start, t_end)

    # Create contact object from Brahe Contact objects and return
    return [Contact(c, station, satellite) for c in contacts]

def get_time_string(t: float) -> str:
    """
    Convert a time in seconds to a human-readable string
    """

    if t < 60:
        return f"{t:.2f} seconds"
    elif t < 3600:
        return f"{math.floor(t / 60)} minutes and {t % 60:.2f} seconds"
    elif t < 86400:
        return f"{math.floor(t / 3600)} hours, {math.floor(t / 60) % 60} minutes, and {t % 60:.2f} seconds"
    else:
        return (f"{math.floor(t / 86400)} days, {math.floor(t / 3600) % 24} hours, {math.floor(t / 60) % 60} minutes, "
                f"and {t % 60:.2f} seconds")

def initialize_eop(filepath: str = None):
    """
    Helper function to initialize the Earth Orientation Parameters (EOP) data for Brahe.
    Some functions in this application require the EOP data to be loaded, namely checking
    Returns:

    """
    if not bh.EOP._initialized:

        if filepath:
            EOP_PATH = pathlib.Path(filepath).absolute()
        else:
            EOP_PATH = (pathlib.Path(__file__).parent.parent /  'data/iau2000A_finals_ab.txt').absolute()

        if EOP_PATH.exists():
            logger.debug(f'EOP data found at "{EOP_PATH}". Loading EOP data from file.')
            bh.EOP.load(EOP_PATH)
        else:
            logger.debug("EOP data not found. Using brahe default EOP data.")
            bh.EOP._initialize()

def ground_stations_from_geojson(geojson: Dict[str, Any]) -> list[GroundStation]:
    """
    Create a list of GroundStation objects from a GeoJSON dictionary
    """
    stations = []
    for feature in geojson['features']:
        properties = feature['properties']
        geometry = feature['geometry']

        if geometry['type'] != 'Point':
            raise ValueError("Only Point geometries are supported")

        if 'provider' not in properties:
            raise ValueError("Missing 'provider' property")

        if 'name' not in properties:
            raise ValueError("Missing 'name' property")

        stations.append(GroundStation(
            name=properties['name'],
            provider=properties['provider'],
            longitude=geometry['coordinates'][0],
            latitude=geometry['coordinates'][1],
            altitude=geometry['coordinates'][2] if len(geometry['coordinates']) > 2 else 0.0
        ))

    return stations


def time_milp_generation(func):
    @wraps(func)
    def wrapper(self, *args, **kwargs):
        # Print the class name and method name at the start
        class_name = self.__class__.__name__
        logger.info(f"Starting generation of {class_name}...")

        # Start timing
        start_time = time.time()

        # Execute the original function
        result = func(self, *args, **kwargs)

        # End timing
        end_time = time.time()
        elapsed_time = end_time - start_time

        # Print the time it took to execute
        logger.info(f"Finished generating {class_name} in {get_time_string(elapsed_time)}.")

        return result

    return wrapper"""
Functions to analyze contact opportunities and optimization outputs
"""

import json
import statistics
from dataclasses import dataclass
from itertools import groupby

from brahe import Epoch

from gsopt.models import GroundStationProvider, Satellite, Contact, GroundStation, OptimizationWindow, DataUnits
from gsopt.plots import plot_stations

import matplotlib.pyplot as plt
import plotly.graph_objs as go


@dataclass
class SolutionContact:
    """
    Dataclass to store information about a contact in a solution
    """
    id: str
    provider_id: str
    satellite_id: str
    station_id: str

    t_start: Epoch
    t_end: Epoch
    t_duration: float

    cost: float
    cost_per_minute: float
    cost_per_pass: float
    datavolume: float

    def __post_init__(self):
        # Ensure that t_start and t_end are Epoch objects
        if not isinstance(self.t_start, Epoch):
            self.t_start = Epoch(self.t_start)

        if not isinstance(self.t_end, Epoch):
            self.t_end = Epoch(self.t_end)

@dataclass
class Solution:
    """
    Dataclass to store information about an optimization solution
    """

    runtime: dict[str, float]
    opt_window: OptimizationWindow
    satellite_dict: dict[str, Satellite]
    provider_dict: dict[str, GroundStationProvider]
    station_dict: dict[str, GroundStation]
    contact_dict: dict[str, SolutionContact]
    selected_provider_dict: dict[str, GroundStationProvider]
    selected_station_dict: dict[str, GroundStation]
    stations_by_satellite: dict[str: list[str]]

    @property
    def satellites(self):
        return list(self.satellite_dict.values())

    @property
    def providers(self):
        return list(self.provider_dict.values())

    @property
    def stations(self):
        return list(self.station_dict.values())

    @property
    def contacts(self):
        return list(self.contact_dict.values())

    @property
    def selected_stations(self):
        return list(self.selected_station_dict.values())


def load_solution_from_file(filepath: str):
    with open(filepath, 'r') as f:
        data = json.load(f)

    return load_solution(data)


def load_solution(data: dict):
    """
    Load an optimization solution from a JSON file and return the satellite, provider, station, and contact
    dictionaries. This function is useful for analyzing the results of an optimization run.

    Args:
        data (dict): Path to the JSON file containing the optimization solution

    Returns:
        solution (Solution): Dataclass containing the satellites, providers, stations, and contacts in the solution
    """

    # Parse Optimization Window
    opt_window = OptimizationWindow(**data["optimization_window"])



    # Parse Providers
    providers = [GroundStationProvider.load_geojson(p) for p in data["providers"]]

    # Extract provider / station dictionaries
    provider_dict = {p.id: p for p in providers}
    station_dict = {s.id: s for p in providers for s in p.stations}

    # Parse Satellites
    satellite_dict = {s['id']:Satellite(**s) for s in data["satellites"]}

    # Parse Contacts
    contact_dict = {c['id']:SolutionContact(**c) for c in data["contacts"]}

    # Extract providers that were selected in the solution
    selected_provider_ids = set([c.provider_id for c in contact_dict.values()])
    selected_provider_dict = {p_id:provider_dict[p_id] for p_id in selected_provider_ids}

    # Extract stations that were selected in the solution
    selected_station_ids = set([c.station_id for c in contact_dict.values()])
    selected_station_dict = {s_id:station_dict[s_id] for s_id in selected_station_ids}

    # Extract stations by satellite
    stations_by_satellite = data['stations_by_satellite']

    return Solution(data['runtime'], opt_window, satellite_dict, provider_dict,
                    station_dict, contact_dict, selected_provider_dict,
                    selected_station_dict, stations_by_satellite)

def plot_solution_stations(solution: Solution, selected_only: bool = False):
    """
    A convenience function to plot the locations of the ground stations in a solution. This wraps utils.plot_stations
    and computes the elevation_min and alt based on minimum of all stations and satellites.


    Args:
        solution:

    Returns:

    """

    if selected_only:
        stations = list(solution.selected_station_dict.values())
    else:
        stations = list(solution.station_dict.values())

    elevation_min = min([s.elevation_min for s in stations])
    alt = min([s.alt for s in solution.satellite_dict.values()])

    return plot_stations([(s.lon, s.lat, s.provider) for s in stations], elevation_min=elevation_min, alt=alt)

def compute_contact_gaps(contacts: list[Contact] | list[SolutionContact]):
    """
    Compute the gaps between contacts in a list of contacts. The gap is defined as the time between the end of one
    contact and the start of the next contact. The function returns a list of contact gaps.

    Args:
        contacts: List of contacts to compute gaps for

    Returns:
        contact_gaps: List of contact gaps
    """

    contact_gaps = {}
    all_gaps = []


    for sat_id, sat_contacts in groupby(contacts, lambda c: c.satellite_id):

        contact_gaps[sat_id] = []

        # Sort the contacts by start time
        sorted_contacts = sorted(sat_contacts, key=lambda c: c.t_start)

        # Compute the gaps between contacts
        for i in range(1, len(sorted_contacts)):
            gap = sorted_contacts[i].t_start - sorted_contacts[i-1].t_end
            gap_stats = {
                'satellite_id': sorted_contacts[i].satellite_id,
                'gap_start': sorted_contacts[i-1].t_end,
                'gap_end': sorted_contacts[i].t_start,
                'gap_duration_s': gap,
                'contact_before_id': sorted_contacts[i-1].id,
                'contact_after_id': sorted_contacts[i].id
            }

            all_gaps.append(gap_stats)
            contact_gaps[sat_id].append(gap_stats)

    contact_gaps['all'] = all_gaps
    return contact_gaps

def compute_gap_statistics(contact_gaps: list[dict]):

    # Compute the total number of gaps
    num_gaps = len(contact_gaps)

    # Compute the average gap duration
    mean_gap_duration = sum([g['gap_duration_s'] for g in contact_gaps]) / num_gaps

    # Compute the maximum gap duration
    max_gap_duration = max([g['gap_duration_s'] for g in contact_gaps])

    # Compute the minimum gap duration
    min_gap_duration = min([g['gap_duration_s'] for g in contact_gaps])

    # Compute 5 and 95 percentiles
    sorted_gap_durations = sorted([g['gap_duration_s'] for g in contact_gaps])

    gap_duration_s_p05 = 0
    gap_duration_s_p95 = 0

    if len(sorted_gap_durations) > 2:
        gap_duration_s_p5bins = statistics.quantiles(sorted_gap_durations, n=20)
        gap_duration_s_p05 = gap_duration_s_p5bins[0]
        gap_duration_s_p95 = gap_duration_s_p5bins[18]

    return {
        'num_gaps': num_gaps,
        'mean_gap_duration_s': mean_gap_duration,
        'max_gap_duration_s': max_gap_duration,
        'min_gap_duration_s': min_gap_duration,
        'gap_duration_s_p05': gap_duration_s_p05,
        'gap_duration_s_p95': gap_duration_s_p95
    }

def compute_contact_statistics(contacts: list[Contact] | list[SolutionContact]):

    # Compute the total number of contacts
    num_contacts = len(contacts)

    # Compute the average contact duration
    mean_duration = sum([c.t_duration for c in contacts]) / num_contacts

    # Compute the maximum contact duration
    max_duration = max([c.t_duration for c in contacts])

    # Compute the minimum contact duration
    min_duration = min([c.t_duration for c in contacts])

    # Compute 5 and 95 percentiles
    sorted_durations = sorted([c.t_duration for c in contacts])
    contact_duration_s_p5bins = statistics.quantiles(sorted_durations, n=20)
    contact_duration_s_p05 = contact_duration_s_p5bins[0]
    contact_duration_s_p95 = contact_duration_s_p5bins[18]

    sat_contact_stats = {}
    sat_gap_stats = {}

    # Compute per-satellite contact statistics
    for sat_id, sat_contacts in groupby(contacts, lambda c: c.satellite_id):
        sat_contacts = list(sat_contacts)
        sat_mean_duration = sum([c.t_duration for c in sat_contacts]) / len(sat_contacts)
        sat_max_duration = max([c.t_duration for c in sat_contacts])
        sat_min_duration = min([c.t_duration for c in sat_contacts])
        sat_sorted_durations = sorted([c.t_duration for c in sat_contacts])

        sat_duration_s_p05 = 0
        sat_duration_s_p95 = 0

        if len(sat_sorted_durations) > 2:
            sat_duration_s_p5bins = statistics.quantiles(sat_sorted_durations, n=20)
            sat_duration_s_p05 = sat_duration_s_p5bins[0]
            sat_duration_s_p95 = sat_duration_s_p5bins[18]

        sat_contact_stats[sat_id] = {
            'num_contacts': len(sat_contacts),
            'mean_duration_s': sat_mean_duration,
            'max_duration_s': sat_max_duration,
            'min_duration_s': sat_min_duration,
            'duration_s_p05': sat_duration_s_p05,
            'duration_s_p95': sat_duration_s_p95
        }

        # Compute contact gaps
        sat_contact_gaps = compute_contact_gaps(sat_contacts)[sat_id]

        if len(sat_contact_gaps) > 0:
            sat_gap_stats[sat_id] = compute_gap_statistics(sat_contact_gaps)
        else:
            sat_gap_stats[sat_id] = {}

    return {
        'num_contacts': num_contacts,
        'mean_duration_s': mean_duration,
        'max_duration_s': max_duration,
        'min_duration_s': min_duration,
        'duration_s_p05': contact_duration_s_p05,
        'duration_s_p95': contact_duration_s_p95,
        'satellite_contact_stats': sat_contact_stats,
        'satellite_gap_stats': sat_gap_stats
    }

def plot_contact_duration_histogram(contacts: list[Contact] | list[SolutionContact], satellite_id: str | None = None, units: str = 'minutes', x_axis_min: float = 0):

    if satellite_id is not None:
        contacts = [c for c in contacts if c.satellite_id == satellite_id]

    durations = [c.t_duration for c in contacts]

    # Change duration into minutes for better visualization
    if units == 'minutes':
        durations = [d/60 for d in durations]

    fig = go.Figure(
        data=[go.Histogram(x=durations)]  # Set bin width to 2
    )

    # Set title
    fig.update_layout(
        title_text="Contact Duration Histogram"
    )

    # Set axis labels
    fig.update_xaxes(title_text=f"Duration ({units})")
    fig.update_yaxes(title_text="Count")

    # Change color of the bars
    fig.update_traces(marker_color='blue', marker_line_color='black', marker_line_width=1)

    # Set x-axis lower limit to 0
    fig.update_xaxes(range=[x_axis_min, None])

    return fig


def plot_contact_gap_histogram(contact_gaps, satellite_id: str | None = None, units: str = 'minutes', x_axis_min: float = 0, bin_width: float = 5.0):

    # Compute contact gaps
    if satellite_id is not None:
        contact_gaps = contact_gaps[satellite_id]
    else:
        contact_gaps = contact_gaps['all']

    gap_durations = [g['gap_duration_s'] for g in contact_gaps]

    # Change duration into minutes for better visualization
    if units == 'minutes':
        gap_durations = [d/60 for d in gap_durations]

    fig = go.Figure(

        data=[go.Histogram(x=gap_durations, xbins={'size': bin_width})]
    )

    # Set title
    fig.update_layout(
        title_text="Contact Gap Histogram"
    )

    # Set axis labels
    fig.update_xaxes(title_text=f"Gap Duration ({units})")
    fig.update_yaxes(title_text="Count")

    # Change color of the bars
    fig.update_traces(marker_color='blue', marker_line_color='black', marker_line_width=1)

    # Set x-axis lower limit to 0

    fig.update_xaxes(range=[x_axis_min, None])

    return fig

def analyze_solution(solution: Solution, data_unit: DataUnits = DataUnits.b):
    """
    Analyze an optimization solution and return statistics about the contacts and gaps in the solution.

    Args:
        solution: Solution object containing the satellites, providers, stations, and contacts in the solution

    Returns:
        contact_stats: Dictionary containing statistics about the contacts in the solution
        gap_stats: Dictionary containing statistics about the gaps between contacts in the solution
    """

    # Compute contact statistics
    contact_stats = compute_contact_statistics(solution.contacts)

    # Compute contact gaps
    contact_gaps = compute_contact_gaps(solution.contacts)

    # Compute gap statistics
    gap_stats = compute_gap_statistics(contact_gaps['all'])

    # Cost and data downlink statistics are repetitions of the values
    # saved in the solution JSON file. They are computed here for convenience and
    # cross-verification.

    # Compute Costs
    total_cost = 0.0
    total_fixed_cost = 0.0
    total_operational_cost = 0.0
    monthly_operational_cost = 0.0

    ## Provider Costs - Fixed
    for pn_id, pn in solution.selected_provider_dict.items():
        total_cost += pn.integration_cost
        total_fixed_cost += pn.integration_cost

    ## Station Costs - Fixed & Operational
    for sn_id, sn in solution.selected_station_dict.items():
        total_cost += sn.setup_cost
        total_fixed_cost += sn.setup_cost

        extr_opt_cost = (12 * solution.opt_window.T_opt) / (365.25 * 86400.0) * sn.monthly_cost
        total_cost += extr_opt_cost
        total_operational_cost += extr_opt_cost
        monthly_operational_cost += sn.monthly_cost

    ## Add Satellite Licensing Costs
    for sat_id in solution.stations_by_satellite.keys():
        for station_id in solution.stations_by_satellite[sat_id]:
            total_cost += solution.station_dict[station_id].per_satellite_license_cost

    ## Contact Costs - Operational
    for cn_id, cn in solution.contact_dict.items():
        total_cost += solution.opt_window.T_opt / solution.opt_window.T_sim * cn.cost
        total_operational_cost += solution.opt_window.T_opt / solution.opt_window.T_sim * cn.cost
        monthly_operational_cost += cn.cost / solution.opt_window.T_sim * (365.25 * 86400.0) / 12.0

    # Data Downlink Statistics
    total_data_downlinked = sum([c.datavolume for c in solution.contacts]) * solution.opt_window.T_opt / solution.opt_window.T_sim
    total_data_downlinked = total_data_downlinked / data_unit.value

    datavolume_by_satellite = {
        'total': {},
        'daily_avg': {},
    }

    for sat_id, sat_contacts in groupby(solution.contacts, lambda c: c.satellite_id):
        datavolume_by_satellite['total'][sat_id] = sum([c.datavolume for c in sat_contacts]) * solution.opt_window.T_opt / solution.opt_window.T_sim / data_unit.value
        datavolume_by_satellite['daily_avg'][sat_id] = datavolume_by_satellite['total'][sat_id] / (solution.opt_window.T_opt / 86400.0)

    return {
        'runtime': {
        },
        'contact_stats': contact_stats,
        'gap_stats': gap_stats,
        'costs': {
            'total_cost': total_cost,
            'total_fixed_cost': total_fixed_cost,
            'total_operational_cost': total_operational_cost,
            'monthly_operational_cost': monthly_operational_cost
        },
        'data_downlink': {
            'total_data_downlinked': total_data_downlinked,
            'datavolume_by_satellite': datavolume_by_satellite
        }
    }'''
Functions for managing ephemeris data
'''

import os
import pathlib

import pathlib
import logging
import datetime
import httpx

import streamlit as st
import polars as pl
import brahe as bh

from gsopt.models import Satellite
from gsopt.utils import get_last_modified_time_as_datetime


logger = logging.getLogger()

EPHEMERIS_PATH = (pathlib.Path(__file__).parent.parent /  'data/celestrak_tles.txt').absolute()

def get_latest_celestrak_tles(output_dir='./data'):
    CELESTRAK_URL = 'https://celestrak.org/NORAD/elements/gp.php?GROUP=ACTIVE&FORMAT=TLE'

    # Create the output directory if it doesn't exist
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    # Extract filename from URL
    filename = os.path.join(output_dir, 'celestrak_tles.txt')

    # Use httpx to get the content from the URL
    response = httpx.get(CELESTRAK_URL, follow_redirects=True)

    # Check if the request was successful (status code 200)
    if response.status_code == 200:
        # Open a file and write the content
        with open(filename, 'w') as fp:
            fp.write(response.text)
        logger.info(f"Saved latest TLE information to {filename}")
    else:
        logger.error(f"Failed to download TLE data from Celestrak. Status code: {response.status_code}")

def get_tles():

    # Check on time of last update
    last_update = get_last_modified_time_as_datetime(EPHEMERIS_PATH)

    logger.info(f'Last TLE update: {last_update.isoformat()}')

    # If the file is older than 1 day, download the latest TLE data
    if (datetime.datetime.now() - last_update).days > 1:
        logger.info(f'TLE data is {(datetime.datetime.now() - last_update).days} days old. Updating...')
        get_latest_celestrak_tles()
    else:
        logger.info(f'TLE data is {(datetime.datetime.now() - last_update).days} days old. TLE data is up to date.')

    # Parse the TLE file and return the records
    return parse_tle_file(EPHEMERIS_PATH)


@st.cache_resource(ttl=3600*12) # Expire cache every 12 hours
def get_satcat_df():
    # Load the TLE data
    tle_data = get_tles()

    # Create a DataFrame from the TLE data
    satcat_df = pl.DataFrame(tle_data, schema={
        'object_name': str,
        'satcat_id': str,
        'epoch': datetime.datetime,
        'altitude': float,
        'semi_major_axis': float,
        'eccentricity': float,
        'inclination': float,
        'right_ascension': float,
        'arg_of_perigee': float,
        'mean_anomaly': float,
        'tle_line0': str,
        'tle_line1': str,
        'tle_line2': str
    })

    return satcat_df

def parse_tle_file(filepath):

    # Create an empty list to store parsed TLE records
    tle_records = []

    with open(filepath, 'r') as file:

        # Read all lines from the file
        lines = file.readlines()

        # Iterate over the lines in the file in groups of 3
        i = 0
        while i < len(lines):
            tle_line0 = lines[i].strip()
            tle_line1 = lines[i + 1].strip()
            tle_line2 = lines[i + 2].strip()

            # Get Information
            object_name = tle_line0.rstrip()

            # Extract TLE data
            tle = bh.TLE(tle_line1, tle_line2)

            satcat_id = tle_line1[2:7]
            tle_epoch = tle.epoch.to_datetime(tsys='UTC')
            semi_major_axis = tle.a
            eccentricity = tle.e
            inclination = tle.i
            right_ascension = tle.RAAN
            arg_of_perigee = tle.w
            mean_anomaly = tle.M

            # Append parsed information to the list
            tle_records.append({
                'object_name': object_name,
                'satcat_id': satcat_id,
                'epoch': tle_epoch,
                'altitude': (semi_major_axis - bh.R_EARTH)/1e3,
                'semi_major_axis': semi_major_axis,
                'eccentricity': eccentricity,
                'inclination': inclination,
                'right_ascension': right_ascension,
                'arg_of_perigee': arg_of_perigee,
                'mean_anomaly': mean_anomaly,
                'tle_line0': tle_line0,
                'tle_line1': tle_line1,
                'tle_line2': tle_line2
            })

            # Move to the next 3-line record
            i += 3

    return tle_records

def satellites_from_constellation(constellation: str, datarate: float = 2.0e9) -> list[Satellite]:

    # Load the TLE data
    tle_data = get_tles()

    # Filter the TLE data for the specified constellation
    constellation_tles = [tle for tle in tle_data if constellation.upper() in tle['object_name']]

    # Create a list of Satellite objects from the TLE data
    satellites = [Satellite(tle['satcat_id'], tle['object_name'], tle['tle_line1'], tle['tle_line2'], datarate=datarate) for tle in constellation_tles]

    return satellites

def satellite_from_satcat_id(satcat_id: str, datarate: float = 2.0e9) -> Satellite:

    # Load the TLE data
    tle_data = get_tles()

    # Filter the TLE data for the specified satcat_id
    tle = next((tle for tle in tle_data if tle['satcat_id'] == str(satcat_id)), None)

    if tle is None:
        raise ValueError(f"Satellite with satcat_id {satcat_id} not found in TLE data")

    # Create a Satellite object from the TLE data
    satellite = Satellite(tle['satcat_id'], tle['object_name'], tle['tle_line1'], tle['tle_line2'], datarate=datarate)

    return satellite